<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"songseungeun.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Front-end web development를 공부합니다.">
<meta property="og:type" content="website">
<meta property="og:title" content="mare nubium">
<meta property="og:url" content="https://songseungeun.github.io/index.html">
<meta property="og:site_name" content="mare nubium">
<meta property="og:description" content="Front-end web development를 공부합니다.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="mare nubium">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://songseungeun.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>mare nubium</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mare nubium</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">구름의 바다 front-end web development</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-prototype/" class="post-title-link" itemprop="url">javascript-prototype</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-07 20:39:39" itemprop="dateCreated datePublished" datetime="2020-03-07T20:39:39+09:00">2020-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-08 23:07:41" itemprop="dateModified" datetime="2020-03-08T23:07:41+09:00">2020-03-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h1><ul>
<li>자바스크립트는 강력한 객체지향 프로그래밍 능력을 지니고 있는 프로토타입 기반의 언어.</li>
<li>자바스크립트를 이루고 있는 거의 모든 것이 객체.<br>( 원시 타입의 값을 제외한 나머지 값들. 함수, 배열, 정규표현식 등 모두 객체 )</li>
<li>클래스는 새로운 객체 생성 메카니즘으로 보는 것이 합당하다.</li>
</ul>
<h2 id="1-객체지향-프로그래밍"><a href="#1-객체지향-프로그래밍" class="headerlink" title="1. 객체지향 프로그래밍"></a>1. 객체지향 프로그래밍</h2><ul>
<li>여러 개의 독립적 단위, 즉 객체(object)들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임.</li>
<li>실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작. 실체는 속성(attribute, property)을 가지고 있고, 실체를 인식하거나 구별할 수 있다.</li>
<li>다양한 속성 중에서 프로그램에 필요한 속성만을 간추려 내어 표현하는 것을 추상화(abstraction)라 한다.</li>
<li>속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료 구조를 객체라 하며, 객체 지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.</li>
<li>원 &gt; 속성(상태): 반지름 (원의 상태를 나타내는 데이터), 동작: 원의 지름, 둘레, 넓이를 구하는 것</li>
<li>객체의 상태 데이터(state) &gt; 프로퍼티</li>
<li>동작(behavior) &gt; 메소드</li>
<li>객체 : 상태데이터 + 동작 =&gt; 하나의 논리적인 단위로 묶은 복합적인 자료구조</li>
<li>각각의 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만, 자신의 고유 기능을 수행하면서 다른 객체와 관계성을 갖을 수 있다.</li>
</ul>
<h2 id="2-상속과-프로토타입"><a href="#2-상속과-프로토타입" class="headerlink" title="2. 상속과 프로토타입"></a>2. 상속과 프로토타입</h2><ul>
<li>상속 (Inheritance) : 객체지향 프로그래밍의 핵심개념, 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것.</li>
<li>자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다. &gt; 기존의 코드를 적극적으로 재사용.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getArea &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; Math.PI 는 원주율을 나타내는 상수이다.</span><br><span class="line">    &#x2F;&#x2F; Math.pow 는 첫번째 인수를 두번째 인수로 거듭제곱한 값을 반환한다.</span><br><span class="line">    return Math.PI * Math.pow(this.radius, 2);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스 생성</span><br><span class="line">&#x2F;&#x2F; 반지름이 1인 인스턴스 생성</span><br><span class="line">const circle1 &#x3D; new Circle(1);</span><br><span class="line">&#x2F;&#x2F; 반지름이 2인 인스턴스 생성</span><br><span class="line">const circle2 &#x3D; new Circle(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는</span><br><span class="line">&#x2F;&#x2F; getArea 메소드를 중복 생성하고 모든 인스턴스가 중복 소유한다.</span><br><span class="line">&#x2F;&#x2F; 따라서 getArea 메소드는 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.</span><br><span class="line">console.log(circle1.getArea &#x3D;&#x3D;&#x3D; circle2.getArea);</span><br><span class="line"></span><br><span class="line">console.log(circle1.getArea());</span><br><span class="line">console.log(circle2.getArea());</span><br></pre></td></tr></table></figure></li>
<li>생성자 함수는 동일한 프로퍼티(메소드 포함) 구조를 갖는 객체를 여러 개 생성할 때 유용하다. </li>
<li>위의 예제의 Circle 생성자 함수는 radius 프로퍼티 값은 일반적으로 인스턴스마다 다르지만, getArea 메소드는 모든 인스턴스가 동일한 내용의 메소드를 사용하므로 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.</li>
<li>동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다. 인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스에도 악영향을 준다.</li>
<li>상속을 통해 불필요한 중복을 제거 할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 </span><br><span class="line">&#x2F;&#x2F; getArea 메소드를 프로토타입에 추가한다.</span><br><span class="line">&#x2F;&#x2F; 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩 되어있다.</span><br><span class="line">Circle.prototype.getArea &#x3D; function () &#123;</span><br><span class="line">  return Math.PI * Math.pow(this.radius, 2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스 생성</span><br><span class="line">const circle1 &#x3D; new Circle(1);</span><br><span class="line">const circle2 &#x3D; new Circle(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는</span><br><span class="line">&#x2F;&#x2F; 프로토타입 Circle.prototype 로부터 getArea 메소드를 상속받는다.</span><br><span class="line">&#x2F;&#x2F; 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.</span><br><span class="line">console.log(circle1.getArea &#x3D;&#x3D;&#x3D; circle2.getArea); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(circle1.getArea());</span><br><span class="line">console.log(circle2.getArea());</span><br></pre></td></tr></table></figure></li>
<li>생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위(부모) 객체 역할을 하는 프로토타입의 모든 프로퍼티와 메소드를 상속받는다.</li>
<li>자신의 상태를 나타내는 radius 프로퍼티만 개별적으로 소유하고 내용이 동일한 메소드는 상속을 통해 공유하여 사용하는 것이다.</li>
<li>상속은 코드의 재사용이란 관점에서 매우 유용하다.</li>
<li>생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 구현해놓으면 모든 인스턴스는 상위객체인 프토토타입의 자산을 공유하며 사용할 수 있다.</li>
</ul>
<h2 id="3-프로토타입-객체"><a href="#3-프로토타입-객체" class="headerlink" title="3. 프로토타입 객체"></a>3. 프로토타입 객체</h2><ul>
<li><p>객체 지향 프로그래밍의 근간을 이루는 객체간 상속(Inheritance)을 구현하기 위해 사용된다.</p>
</li>
<li><p>객체의 상위(부모) 객체 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메소드포함)를 제공한다.</p>
</li>
<li><p>상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.</p>
</li>
<li><p>모든 객체는 <code>[[Prototype]]</code> 이라는 내부 슬롯을 갖고, 내부 슬롯의 값으로 프로토타입의 참조를 저장한다.</p>
</li>
<li><p>하나의 프로토타입을 갖으며, 프로토타입은 객체의 생성방식에 의해 결정된다.</p>
</li>
<li><p>Object.prototype : 객체 리터럴에 의해 생성된 객체의 프로토타입</p>
</li>
<li><p>생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체 : 생성자 함수에 의해 생성된 객체의 프로토타입</p>
</li>
<li><p>모든 객체는 하나의 프로토타입을 갖는다. 프로토타입은 null 이거나 객체이다. </p>
</li>
<li><p>객체와 프로토타입과 생성자 함수는 서로 연결되어 있다.</p>
</li>
<li><p>객체는 <code>__proto__</code> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 자신의 <code>[[Prototype]]</code> 내부 슬롯이 가리키는 객체에 접근할 수 있다.</p>
</li>
<li><p>프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있다. 생성자 함수는 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.</p>
</li>
</ul>
<h3 id="3-1-proto-접근자-프로퍼티"><a href="#3-1-proto-접근자-프로퍼티" class="headerlink" title="3-1. proto 접근자 프로퍼티"></a>3-1. <strong>proto</strong> 접근자 프로퍼티</h3><ul>
<li><p>모든 객체는 <code>__proto__</code> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 <code>[[Prototype]]</code> 내부 슬롯에 접근할 수 있다.</p>
</li>
<li><p>내부 슬롯은 프로퍼티가 아니다. 따라서 직접 접근할 수 없고, 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.</p>
</li>
<li><p><code>[[Prototype]]</code> 내부 슬롯에도 직접 접근할 수 없으며, <code>__proto__</code> 접근자 프로퍼티를 통해 간접적으로 내부 슬롯의 값, 프로토타입에 접근할 수 있다.</p>
</li>
<li><p>접근자 프로퍼티는 자체적으로는 값을 갖지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수 (Accessor function)로 구성된 프로퍼티다.</p>
</li>
<li><p>Object.prototype의 프로퍼티인 <code>__proto__</code> 접근자 프로퍼티는 getter/setter 함수라고 부르는 접근자 함수를 통해 <code>[[Prototype]]</code> 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당한다.</p>
</li>
<li><p><code>__proto__</code> 접근자 프로퍼티는 상속을 통해 사용된다.</p>
</li>
<li><p><code>__proto__</code> 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype 의 프로퍼티이다. 모든 객체는 상속을 통해 Object.prototype.<strong>proto</strong> 접근자 프로퍼티를 사용할 수 있다.</p>
</li>
<li><p><code>__proto__</code> 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유</p>
</li>
<li><p><code>[[Prototype]]</code> 내부 슬롯의 값, 즉 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함이다.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const parent &#x3D; &#123;&#125;;</span><br><span class="line">const child &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; child의 프로토타입을 parent로 지정</span><br><span class="line">child.__proto__ &#x3D; parent;</span><br><span class="line">parent.__proto__ &#x3D; child; &#x2F;&#x2F; TypeError</span><br></pre></td></tr></table></figure>

<ul>
<li><p>순환참조(circular reference) 적인 프로토타입 체인이 만들어지면 프로토타입 체인 종점이 존재하지 않기 때문에 프로토타입 체인에서 프로퍼티를 검색할 때 무한루프에 빠진다.</p>
</li>
<li><p>무조건적으로 프토토타입을 교체할 수 없도록 <code>__proto__</code> 접근자 프로퍼티를 통해 프로토타입에 접근하고 교체하도록 구현되어있다. &gt; <code>단방향 링크드 리스트</code></p>
</li>
<li><p><code>__proto__</code> 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천이다.</p>
</li>
<li><p>현재 대부분의 브라우저(IE 11 이상)가 <code>__proto__</code> 를 지원하고 있다. 하지만 코드 내에서 <code>__proto__</code>를 직접 사용하는 것은 추천하지 않는다.</p>
</li>
<li><p>모든 객체가 <code>__proto__</code> 접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문이다. 직접 상속을 통해 아래와 같이 Object.prototype을 상속받지 않는 객체를 생성할 수도 있다.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; obj는 프로토타입 체인의 종점이다. 따라서 Object.__proto__를 상속받을 수 없다.</span><br><span class="line">const obj &#x3D; Object.create(null);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj는 Object.__proto__를 상속받을 수 없다.</span><br><span class="line">console.log(obj.__proto__); &#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; 따라서 Object.getPrototypeOf 메소드를 사용하는 편이 좋다.</span><br><span class="line">console.log(Object.getPrototypeOf(obj)); &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.getPrototypeOf 메소드 : <code>__proto__</code> 접근자 프로퍼티 대신 프로토타입의 참조를 취득할 경우</li>
<li>Object.setPrototypeOf 메소드 : 프로토타입을 교체하는 경우</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line">const parent &#x3D; &#123; x: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 취득</span><br><span class="line">Object.getPrototypeOf(obj);</span><br><span class="line">console.log(Object.getPrototypeOf(obj));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 교체</span><br><span class="line">Object.setPrototypeOf(obj, parent);</span><br><span class="line">console.log(Object.setPrototypeOf(obj, parent));</span><br><span class="line">&#x2F;&#x2F; obj.__proto__ &#x3D; parent;</span><br><span class="line"></span><br><span class="line">console.log(obj.x); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.getPrototypeOf 메소드 &gt; getObject.prototype.<strong>proto</strong><br>(ES5 도입된 메소드, IE9 이상 지원)</li>
<li>Object.setPrototypeOf 메소드 &gt; setObject.prototype.<strong>proto</strong><br>(ES6 도입된 메소드, IE11 이상 지원)</li>
</ul>
<h2 id="3-2-함수-객체의-prototype-프로퍼티"><a href="#3-2-함수-객체의-prototype-프로퍼티" class="headerlink" title="3-2. 함수 객체의 prototype 프로퍼티"></a>3-2. 함수 객체의 prototype 프로퍼티</h2><ul>
<li>함수 객체 <code>__proto__</code> 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. </li>
<li>함수 객체의 prototype 프로퍼티 &gt; 생성자 함수가 생성할 인스턴스의 프로토타입</li>
<li>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 객체는 prototype 프로퍼티를 소유한다.</span><br><span class="line">console.log((function () &#123;&#125;).hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span><br><span class="line">console.log(&#123;&#125;.hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<ul>
<li><p>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로서 사용될 때, 생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킨다.</p>
</li>
<li><p>생성자 함수로서 호출할 수 없는 함수 &gt; Arrow, Method 인 함수 = non-constructor는 프로토타입이 생성되지 않으며, prototype 프로퍼티도 소유하지 않는다.</p>
</li>
<li><p>일반 함수도 prototype 프로퍼티를 소유하지만 객체를 생성하지 않는 일반 함수의 prototype 프로퍼티는 아무런 의미가 없다.</p>
</li>
<li><p><code>__proto__</code> 접근자 프로퍼티 (Object.prototype로 부터 상속받은) 와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다. 하지만 프로퍼티를 사용하는 주체가 다르다.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">구분</th>
<th align="center">소유</th>
<th align="center">값</th>
<th align="center">사용 주체</th>
<th align="center">사용 목적</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>__proto__</code> 접근자 프로퍼티</td>
<td align="center">모든 객체</td>
<td align="center">프로토타입의 참조</td>
<td align="center">모든 객체</td>
<td align="center">모든 객체가 상속을 위해 자신의 프로토타입에 접근하기 위해 사용</td>
</tr>
<tr>
<td align="center">prototype 프로퍼티</td>
<td align="center">함수 객체</td>
<td align="center">프로토타입의 참조</td>
<td align="center">생성자 함수</td>
<td align="center">생성자 함수가 자신이 생성할 객체(인스턴스) 의 프로토타입을 할당하기 위해 사용</td>
</tr>
</tbody></table>
<ul>
<li>생성자 함수로 객체를 생성한 후 <code>__proto__</code> 접근자 프로퍼티와 prototype 프로퍼티로 프로토타입 객체에 접근해보자.</li>
</ul>
<h2 id="3-3-프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#3-3-프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="3-3. 프로토타입의 constructor 프로퍼티와 생성자 함수"></a>3-3. 프로토타입의 constructor 프로퍼티와 생성자 함수</h2><ul>
<li>모든 프로토타입은 constructor 프로퍼티를 갖는다.</li>
<li>constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.</li>
<li>생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Person(&#39;Lee&#39;);</span><br><span class="line">const you &#x3D; new Person(&#39;Song&#39;);</span><br><span class="line"></span><br><span class="line">console.log(Person.prototype);</span><br><span class="line">console.log(me.__proto__);</span><br><span class="line"></span><br><span class="line">console.log(me);</span><br><span class="line">console.log(me.name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Person &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Person &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Person &#123; name: &#39;Lee&#39; &#125;</span><br><span class="line">&#x2F;&#x2F; Lee</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Person.prototype: Person 생성자 함수는 prototype 프로퍼티를 통해</span><br><span class="line">&#x2F;&#x2F; 자신이 생성할 인스턴스(me)의 프로토타입을 할당</span><br><span class="line">&#x2F;&#x2F; me.__proto__: 객체 me의 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입에 접근</span><br><span class="line">&#x2F;&#x2F; 결국 Person.prototype 과 me.__proto__는 결국 동일한 프로토타입을 가리킨다.</span><br><span class="line">console.log(Person.prototype &#x3D;&#x3D;&#x3D; me.__proto__); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; me 객체의 생성자 함수는 Person 이다.</span><br><span class="line">console.log(me.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(you);</span><br><span class="line">console.log(you.name);</span><br><span class="line"></span><br><span class="line">console.log(you.constructor);</span><br></pre></td></tr></table></figure>

<h2 id="4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h2><ul>
<li>생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다. 이 때 생성자 함수는 인스턴스를 생성한 생성자 함수이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; obj 객체를 생성한 생성자 함수는 Object 이다.</span><br><span class="line">const obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add 함수 객체를 생성한 생성자 함수는 Function이다.</span><br><span class="line">const add &#x3D; new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; me 객체를 생성한 생성자 함수는 Person이다.</span><br><span class="line">const me &#x3D; new Person(&#39;Lee&#39;);</span><br><span class="line"></span><br><span class="line">console.log(obj);</span><br><span class="line">console.log(Object);</span><br><span class="line">console.log(add);</span><br><span class="line">console.log(add(1, 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 리터럴</span><br><span class="line">const obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 리터럴</span><br><span class="line">const add2 &#x3D; function (a, b) &#123; return a + b; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 배열 리터럴</span><br><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 정규표현식 리터럴</span><br><span class="line">const regexr &#x3D; &#x2F;is&#x2F;ig;</span><br><span class="line"></span><br><span class="line">console.log(obj2);</span><br><span class="line">console.log(add2(2, 3));</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(regexr);</span><br></pre></td></tr></table></figure>

<ul>
<li>리터럴 표기법에 의해 생성된 객체도 프로토타입이 존재하지만, 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 객체 obj는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성하였다.</span><br><span class="line">const obj3 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 하지만 객체 obj의 생성자 함수는 Object 생성자 함수이다.</span><br><span class="line">console.log(obj.constructor &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<ul>
<li>객체 리터럴에 의해 생성된 객체가 Object 생성자 함수와 constructor 프로퍼티로 연결되어있다.</li>
<li>Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다.</li>
<li>인수가 전달되지 않았을 때 추상연산 ObjectCreate을 호출하여 빈 객체를 생성한다. 인수가 전달된 경우에는 인수를 객체로 변환한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/review-type-casting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/review-type-casting/" class="post-title-link" itemprop="url">review-type-casting</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-04 21:06:51" itemprop="dateCreated datePublished" datetime="2020-03-04T21:06:51+09:00">2020-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-10 10:51:15" itemprop="dateModified" datetime="2020-03-10T10:51:15+09:00">2020-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/review/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="자바스크립트-복습-타입-변환과-단축-평가"><a href="#자바스크립트-복습-타입-변환과-단축-평가" class="headerlink" title="자바스크립트 복습 - 타입 변환과 단축 평가"></a>자바스크립트 복습 - 타입 변환과 단축 평가</h1><ol>
<li><p>암묵적 타입 변환과 명시적 타입 변환<br>중요한 키워드 : 개발자의 의도<br>자바스크립트 엔진이 값을 평가하다가<br>예상하지 않았던 타입이 들어왔을 때 오류를 내지 않고 타입을 바꿔버리는 등의 동작을 일으키는 것이 암묵적 타입변환.<br>개발자가 프로그래밍을 할 때 타입변환이 필요한 부분에서 그 원리를 이용해서 의도적으로 타입변환을 할때 쓰는 것도  명시적 타입 변환이라고 한다<br>그 외에는 표준 빌트인 생성자 함수를 new 연산자 없이 호출하거나<br>빌트인 메소드를 이용하는 방법이 있다.<br>암묵적 타입변환과 명시적 타입변환을 어떤 방법으로 나누는 것은 적합하지 않고 경우에 따라서 그 원리를 사용하면 됨</p>
</li>
<li><p>단축평가 : 논리곱, 논리합<br>논리곱 &amp;&amp; AND 논리합 || OR 이 있는데<br>AND는 둘 다 true 여야 true 로 평가가 되고 하나라도 false 면 false 로 평가된다.<br>OR는 하나만 true 여도 true로 평가되고 둘 다 false 여야 false로 평가된다.<br>그래서 ‘Dog’ &amp;&amp; ‘Cat’ 의 예제에서<br>‘’ 빈 문자열 false 외에 모든 문자열은 true, truthy 값으로 평가되므로<br>Dog &amp;&amp; Cat 이면 &amp;&amp;는 첫번째가 true여도 두번째까지 확인해야 하므로 두번째 Cat을 확인하고 Cat을 반환하고<br>Dog || Cat 에서 ||는 첫번째만 true 여도 평가가 가능하므로 Dog를 확인 후 바로 Dog를 반환한다.</p>
</li>
<li><p>객체 - 객체 리터럴<br>프로퍼티키와 프로퍼티 값으로 이루어진 자료구조.<br>객체는 원시타입과 달리 변경 가능한 값.</p>
</li>
</ol>
<p>객체리터럴은 객체를 생성하는 표기법<br>중괄호{} 내에 0개 이상의 프로퍼티를 정의.<br>변수에 할당이 이루어지는 시점에 객체리터럴을 해석하여 생성함.</p>
<ol start="4">
<li>값에 의한 전달, 참조에 의한 전달<br>값에 의한 전달은 원시타입을 원시값을 변수에 할당한 후 다른 변수로 그 변수를 참조한 뒤 원래 변수의 값을 재할당한 경우 메모리 공간에서 따로 관리를 하기때문에 그 값을 복사한 다른 변수가 영향을 받지 않는다는 것.</li>
</ol>
<p>참조에 의한 전달은 객체를 아까와 같은 방법으로 다른 변수가 참조했을 때 객체에 어떤 프로퍼티를 추가하거나 변경했을 때 객체의 변수는 참조값을 메모리에 저장하고 있으므로 복사한 변수도 같은 참조값을 저장하기 때문에 객체를 추가 변경했을때 복사한 변수가 변경된 값을 그대로 출력하는 등 영향을 받는다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-first-class-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-first-class-object/" class="post-title-link" itemprop="url">javascript-first-class-object</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-04 13:47:19 / Modified: 18:05:57" itemprop="dateCreated datePublished" datetime="2020-03-04T13:47:19+09:00">2020-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수와-일급-객체"><a href="#함수와-일급-객체" class="headerlink" title="함수와 일급 객체"></a>함수와 일급 객체</h1><h2 id="1-일급-객체"><a href="#1-일급-객체" class="headerlink" title="1. 일급 객체"></a>1. 일급 객체</h2><blockquote>
<h4 id="아래와-같은-조건을-만족하는-객체를-일급-객체-first-class-object-라-한다"><a href="#아래와-같은-조건을-만족하는-객체를-일급-객체-first-class-object-라-한다" class="headerlink" title="아래와 같은 조건을 만족하는 객체를 일급 객체(first-class object)라 한다."></a>아래와 같은 조건을 만족하는 객체를 <code>일급 객체(first-class object)</code>라 한다.</h4><ol>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개 변수에게 전달할 수 있다.</li>
<li>함수의 결과값으로 반환할 수 있다.</li>
</ol>
<ul>
<li>자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체이다.</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수와 일급 객체</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1. 함수는 무명의 리터럴로 생성할 수 있다.</span><br><span class="line">&#x2F;&#x2F; 2. 함수는 변수에 저장할 수 있다.</span><br><span class="line">&#x2F;&#x2F; 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.</span><br><span class="line"></span><br><span class="line">const increase &#x3D; function (num) &#123;</span><br><span class="line">  return ++num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const decrease &#x3D; function (num) &#123;</span><br><span class="line">  return --num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 함수는 객체에 저장할 수 있다.</span><br><span class="line">const predicates &#x3D; &#123; increase, decrease &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 함수의 매개 변수에게 전달할 수 있다.</span><br><span class="line">&#x2F;&#x2F; 4. 함수의 반환값으로 사용할 수 있다.</span><br><span class="line">function makeCounter(predicate) &#123;</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  return function () &#123;</span><br><span class="line">    num &#x3D; predicate(num);</span><br><span class="line">    return num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 함수는 매개 변수에게 함수를 전달할 수 있다.</span><br><span class="line">const increaser &#x3D; makeCounter(predicates.increase);</span><br><span class="line">console.log(increaser());</span><br><span class="line">console.log(increaser());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 함수는 매개 변수에게 함수를 전달할 수 있다.</span><br><span class="line">const decreaser &#x3D; makeCounter(predicates.decrease);</span><br><span class="line">console.log(decreaser());</span><br><span class="line">console.log(decreaser());</span><br></pre></td></tr></table></figure>
<ul>
<li>함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다.</li>
<li>함수는 값을 사용할 수 있는 곳(변수 할당문, 객체의 프로퍼티, 배열의 요소, 함수 호출의 인수, 함수 반환문)이라면 어디서든지 리터럴로 정의할 수 있으며 런타임에 함수 객체로 평가된다.</li>
<li>함수 객체는 몇 가지 고유한 프로퍼티를 갖는 것을 제외하면 일반 객체와 동일하다. &gt; 일반 객체와 같이 함수의 매개 변수에 전달할 수 있으며 함수의 결과값으로 반환할 수도 있다. 이는 함수형 프로그래밍을 가능케하는 자바스크립트의 장점 중에 하나이다.</li>
</ul>
<ul>
<li>함수형 프로그래밍 : 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화하여 불변성을 지향하는 프로그래밍 패러다임이다. 함수형 프로그래밍 패러다임에서 매개 변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를 고차 함수(Higher-Order Function, HOF)라 한다.</li>
</ul>
<ul>
<li>함수는 객체이지만 일반 객체와는 차이가 있다. 일반 객체는 호출할 수 없지만 함수 객체는 호출할 수 있다. 그리고 일반 객체에는 없는 함수 고유의 프로퍼티를 소유한다.</li>
</ul>
<h2 id="2-함수-객체의-프로퍼티"><a href="#2-함수-객체의-프로퍼티" class="headerlink" title="2. 함수 객체의 프로퍼티"></a>2. 함수 객체의 프로퍼티</h2><ul>
<li><p>함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다.</p>
</li>
<li><p>console.dir(브라우저 콘솔) 메소드를 사용하여 함수 객체의 내부를 들여다 보자.</p>
</li>
<li><p>일반 객체에는 없는 arguments, caller, length, name, prototype 프로퍼티가 함수 객체에는 존재한다. 이 프로퍼티들의 프로퍼티 어트리뷰트를 Object.getOwnPropertyDescriptor 메소드로 확인해보면 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 객체의 프로퍼티</span><br><span class="line">function square(number) &#123;</span><br><span class="line">  return number * number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.dir(square);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; arguments, caller, length, name, prototype 프로퍼티는</span><br><span class="line">&#x2F;&#x2F; 모두 square 함수 객체의 데이터 프로퍼티이다.</span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;arguments&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;arguments&#39;));</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;caller&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;caller&#39;));</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;length&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;length&#39;));</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;name&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;name&#39;));</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;prototype&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;prototype&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; __proto__는 square 함수 객체의 프로퍼티가 아니다.</span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;__proto__&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;__proto__&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; __proto__는 Object.prototype 객체의 접근자 프로퍼티이다.</span><br><span class="line">&#x2F;&#x2F; square 함수 객체는 Object.prototype 객체로부터 __proto__ 접근자 프로퍼티를 상속받는다.</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, &#39;__proto__&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(Object.prototype, &#39;__proto__&#39;));</span><br></pre></td></tr></table></figure></li>
<li><p><code>__proto__</code> 는 접근자 프로퍼티이며 함수 객체의 프로퍼티가 아닌 Object.prototype 객체의 프로퍼티를 상속받은 것을 알 수 있다.</p>
</li>
</ul>
<h3 id="2-1-arguments-프로퍼티"><a href="#2-1-arguments-프로퍼티" class="headerlink" title="2-1. arguments 프로퍼티"></a>2-1. arguments 프로퍼티</h3><ul>
<li>함수 객체의 arguments 프로퍼티 값은 arguments 객체이다.</li>
<li>arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체(array-like object)이며 함수 내부에서 지역 변수처럼 사용된다.</li>
<li>함수 외부에서는 사용할 수 없다.</li>
</ul>
<ul>
<li>arguments 프로퍼티 : ES3부터 표준에서 폐지되었다. Function.arguments와 같은 사용방법은 권장되지 않으며 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체를 참조하도록 한다.</li>
</ul>
<ul>
<li>함수 호출 시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; arguments 프로퍼티</span><br><span class="line">function multiply(x, y) &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(multiply());</span><br><span class="line">console.log(multiply(1));</span><br><span class="line">console.log(multiply(1, 2));</span><br><span class="line">console.log(multiply(1, 2, 3));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [Arguments] &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; NaN</span><br><span class="line">&#x2F;&#x2F; [Arguments] &#123; &#39;0&#39;: 1 &#125;</span><br><span class="line">&#x2F;&#x2F; NaN</span><br><span class="line">&#x2F;&#x2F; [Arguments] &#123; &#39;0&#39;: 1, &#39;1&#39;: 2 &#125;</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; [Arguments] &#123; &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3 &#125;</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<ul>
<li>함수를 정의할 때 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다.</li>
<li>즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다.</li>
<li>선언된 매개변수의 개수보다 인수가 적게 전달했을 경우 undefined 로 초기화된 상태를 유지한다.</li>
<li>매개변수의 개수보다 인수를 더 많이 전달한 경우 초과된 인수는 무시된다.</li>
<li>초과된 인수가 버려지는 것은 아니고, 암묵적으로 arguments 객체의 프로퍼티로 보관된다.</li>
<li>arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타낸다.</li>
<li>arguments 객체의 callee 프로퍼티는 호출되어 arguments 객체를 생성한 함수, 즉 함수 자신을 가리키고 arguments 객체의 length 프로퍼티는 인수의 개수를 가리킨다.</li>
</ul>
<ul>
<li>arguments 객체의 symbol(symbol.iterator) 프로퍼티 : arguments 객체를 순회 가능한 자료구조인 이터러블(iterable)로 만들기 위한 프로퍼티다. symbol.iterator를 프로퍼티 키로 사용한 메소드를 구현하는 것에 의해 이터러블이 된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; iterator</span><br><span class="line"></span><br><span class="line">function multiply(x, y) &#123;</span><br><span class="line">  &#x2F;&#x2F; 이터레이터</span><br><span class="line">  const iterator &#x3D; arguments[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 이터레이터의 next 메소드를 호출하여 이터러블 객체 arguments를 순회</span><br><span class="line">  console.log(iterator.next());</span><br><span class="line">  console.log(iterator.next());</span><br><span class="line">  console.log(iterator.next());</span><br><span class="line">  console.log(iterator.next());</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; &#123; value: 1, done: false &#125;</span><br><span class="line">  &#x2F;&#x2F; &#123; value: 2, done: false &#125;</span><br><span class="line">  &#x2F;&#x2F; &#123; value: 3, done: false &#125;</span><br><span class="line">  &#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br><span class="line"></span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply(1, 2, 3);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>선언된 매개변수의 개수와 함수 호출시에 전달하는 인수의 개수를 확인하지 않은 자바스크립트의 특성때문에 런타임 시에 호출된 함수의 인자 개수를 확인하고, 이에 따라 함수의 동작을 달리 정의할 필요가 있을 수 있다. 이 때 유용하게 사용되는 것이 arguments 객체이다.</p>
</li>
<li><p>arguments 객체는 매개변수 개수를 확정할 수 없는 <code>가변 인자 함수</code>를 구현할 때 유용하게 사용된다.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  let res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로</span><br><span class="line">  &#x2F;&#x2F; for 문으로 순회할 수 있다.</span><br><span class="line">  for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    res +&#x3D; arguments[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum());</span><br><span class="line">console.log(sum(1, 2));</span><br><span class="line">console.log(sum(1, 2, 3));\</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<ul>
<li>arguments 객체는 배열의 형태로 인자 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다.</li>
<li>유사배열객체란 length 프로퍼티를 가진 객체로 for문으로 순회할 수 있는 객체를 말한다.</li>
</ul>
<ul>
<li>유사배열객체와 이터러블 : ES6에서 도입된 이터레이션 프로토콜을 준수하면 순회 가능한 자료 구조인 이터러블이 된다. 이터러블의 개념이 없었던 ES5 에서 arguments 객체는 유사 배열 객체로 구분되었다. 하지만 이터러블이 도입된 ES6 부터 arguments 객체는 유사 배열 객체이면서 이터러블이다.</li>
</ul>
<ul>
<li>유사 배열 객체는 배열이 아니므로 배열 메소드를 사용할 경우 에러가 발생하게 된다.</li>
<li>배열 메소드를 사용하려면 Function.prototype.call, Function.prototype.apply 를 사용해 간접 호출해야 하는 번거로움이 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; function.prototype.call, function.prototype.apply</span><br><span class="line"></span><br><span class="line">function sum() &#123;</span><br><span class="line">  &#x2F;&#x2F; arguments 객체를 배열로 변환</span><br><span class="line">  const array &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">  return array.reduce(function (pre, cur) &#123;</span><br><span class="line">    return pre + cur;</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1, 2, 3, 4, 5)); &#x2F;&#x2F; 15</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 에서는 Rest 파라미터를 도입.</span><br><span class="line">&#x2F;&#x2F; ES6 Rest parameter</span><br><span class="line">function sum2( ...args ) &#123;</span><br><span class="line">  return args.reduce((pre, cur) &#x3D;&gt; pre + cur, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1, 2, 3, 4, 5)); &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>
<ul>
<li>이러한 번거로움을 해결하기 위해 ES6 에서는 Rest 파라미터를 도입했다.</li>
</ul>
<h3 id="2-3-length-프로퍼티"><a href="#2-3-length-프로퍼티" class="headerlink" title="2-3. length 프로퍼티"></a>2-3. length 프로퍼티</h3><ul>
<li>함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킨다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; length property</span><br><span class="line"></span><br><span class="line">function foo() &#123;&#125;</span><br><span class="line">console.log(foo.length); &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">function bar(x) &#123;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">console.log(bar.length); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">function baz(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line">console.log(baz.length); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<ul>
<li>arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있으므로 주의하여야 한다.</li>
<li>arguments 객체의 length 프로퍼티는 인자의 개수</li>
<li>함수 객체의 length 프로퍼티는 매개변수의 개수.</li>
</ul>
<h3 id="2-4-name-프로퍼티"><a href="#2-4-name-프로퍼티" class="headerlink" title="2-4. name 프로퍼티"></a>2-4. name 프로퍼티</h3><ul>
<li>함수 객체의 name 프로퍼티는 함수 이름을 나타낸다. </li>
<li>ES5 와 ES6 에서 동작을 달리하므로 주의.</li>
<li>익명 함수 표현식의 경우 ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다.</li>
<li>ES6에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; name property</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 기명 함수 표현식</span><br><span class="line">var namedFunc &#x3D; function foo() &#123;&#125;;</span><br><span class="line">console.log(namedFunc.name); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 익명 함수 표현식</span><br><span class="line">var anonymousFunc &#x3D; function() &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; ES5: name 프로퍼티는 빈 문자열을 값으로 갖는다.</span><br><span class="line">&#x2F;&#x2F; ES6: name 프로퍼티는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.</span><br><span class="line">console.log(anonymousFunc.name); &#x2F;&#x2F; anonymousFunc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 선언문(Function declaration)</span><br><span class="line">function bar() &#123;&#125;</span><br><span class="line">console.log(bar.name); &#x2F;&#x2F; bar</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 이름과 함수 객체를 가리키는 변수 이름은 의미가 다르다.</li>
<li>함수를 호출할 때는 함수 이름이 아닌 함수 객체를 가리키는 변수 이름으로 호출한다.</li>
</ul>
<h3 id="2-5-proto-접근자-프로퍼티"><a href="#2-5-proto-접근자-프로퍼티" class="headerlink" title="2-5. __proto__ 접근자 프로퍼티"></a>2-5. <code>__proto__</code> 접근자 프로퍼티</h3><ul>
<li>모든 객체는 <code>[[Prototype]]</code> 이라는 내부 슬롯을 갖는다.</li>
<li><code>[[Prototype]]</code> 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.</li>
<li><code>__proto__</code> 프로퍼티는 <code>[[Prototype]]</code>내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다.</li>
<li>내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.</li>
<li><code>[[Prototype]]</code>내부 슬롯에도 간접적으로 프로토타입 객체에 접근할 수 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; __proto__ 접근자 프로퍼티</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype 이다.</span><br><span class="line">console.log(obj.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인</span><br><span class="line">&#x2F;&#x2F; Object.prototype의 프로퍼티를 상속받는다.</span><br><span class="line">&#x2F;&#x2F; hasOwnProperty 메소드는 Object.prototype 의 메소드이다.</span><br><span class="line">console.log(obj.hasOwnProperty(&#39;a&#39;)); &#x2F;&#x2F; true</span><br><span class="line">console.log(obj.hasOwnProperty(&#39;__proto__&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>(왜 true, false 가 나오는지 다시 체크할 것)</p>
<h3 id="2-6-prototype-프로퍼티"><a href="#2-6-prototype-프로퍼티" class="headerlink" title="2-6. prototype 프로퍼티"></a>2-6. prototype 프로퍼티</h3><ul>
<li>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다.</li>
<li>일반 객체에는 prototype 프로퍼티가 없다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; prototype property</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 객체는 prototype 프로퍼티를 소유한다.</span><br><span class="line">console.log((function() &#123;&#125;).hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span><br><span class="line">console.log((&#123;&#125;).hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure></li>
<li>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-constructor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-constructor/" class="post-title-link" itemprop="url">javascript-constructor</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-03 16:13:59 / Modified: 22:37:08" itemprop="dateCreated datePublished" datetime="2020-03-03T16:13:59+09:00">2020-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="생성자-함수에-의한-객체-생성"><a href="#생성자-함수에-의한-객체-생성" class="headerlink" title="생성자 함수에 의한 객체 생성"></a>생성자 함수에 의한 객체 생성</h1><h2 id="1-Object-생성자-함수"><a href="#1-Object-생성자-함수" class="headerlink" title="1. Object 생성자 함수"></a>1. Object 생성자 함수</h2><ul>
<li>new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다.</li>
<li>빈 객체에 프로퍼티 또는 메소드를 추가하여 객체를 완성할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const brockhampton &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">brockhampton.name &#x3D; &#39;브록햄튼&#39;;</span><br><span class="line">brockhampton.music &#x3D; &#39;SUGAR&#39;;</span><br><span class="line">brockhampton.likedSong &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;요즘은 &#39; + this.name + &#39;의 &#39; + this.music + &#39;가 제일 좋아&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(brockhampton);</span><br><span class="line">brockhampton.likedSong();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; name: &#39;브록햄튼&#39;, music: &#39;SUGAR&#39;, likedSong: [Function (anonymous)] &#125;</span><br><span class="line">&#x2F;&#x2F; 요즘은 브록햄튼의 SUGAR가 제일 좋아</span><br></pre></td></tr></table></figure></li>
<li>생성자 함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수</li>
<li>String, Number, Boolean, Function, Array, Date, RegExp 등의 빌트인 생성자 함수를 제공한다.</li>
<li>객체를 생성하는 방법은 객체 리터럴을 사용하는 것이 더 간편하다.</li>
</ul>
<h2 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2. 생성자 함수"></a>2. 생성자 함수</h2><h3 id="2-1-객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#2-1-객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="2-1. 객체 리터럴에 의한 객체 생성 방식의 문제점"></a>2-1. 객체 리터럴에 의한 객체 생성 방식의 문제점</h3><ul>
<li><p>객체 리터럴에 의한 객체 생성 방식은 직관적이고 간편하다. 하지만 단 하나의 객체만을 생성하므로, 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const circle1 &#x3D; &#123;</span><br><span class="line">  radius: 5,</span><br><span class="line">  getDiameter() &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(circle1.getDiameter()); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">const circle2 &#x3D; &#123;</span><br><span class="line">  radius: 10,</span><br><span class="line">  getDiameter() &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(circle2.getDiameter()); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>
</li>
<li><p>원을 표현한 객체인 circle1 객체와 circle2 객체는 프로퍼티 구조가 동일하다. 이 때 객체 고유의 상태 데이터인 radius 프로퍼티의 값은 객체마다 다를 수 있지만 getDiameter 메소드는 완전히 동일하다.</p>
</li>
<li><p>객체는 프로퍼티를 통해 객체 고유의 상태를 표현한다. 그리고 메소드를 통해 상태 데이터인 프로퍼티를 참조하고 조작하는 동작을 표현한다. 따라서 프로퍼티는 객체마다 프로퍼티 값이 다를 수 있지만 메소드는 내용이 동일한 경우가 일반적이다.</p>
</li>
<li><p>객체 리터럴에 의해 객체를 생성하는 경우, 프로퍼티 구조가 동일함에도 불구하고 매번 같은 프로퍼티와 메소드를 기술해야 한다. 위 예제처럼 객체가 한두개라면 넘어갈 수도 있겠지만 만약 수십개의 객체를 생성해야 한다면 문제가 크다.</p>
</li>
</ul>
<h2 id="2-2-생성자-함수에-의한-객체-생성-방식의-장점"><a href="#2-2-생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="2-2. 생성자 함수에 의한 객체 생성 방식의 장점"></a>2-2. 생성자 함수에 의한 객체 생성 방식의 장점</h2><ul>
<li>생성자 함수에 의한 객체 생성 방식은 마치 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</li>
</ul>
<ul>
<li>this : this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수 (Self-referencing variable)이다. this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">함수 호출 방식</th>
<th align="center">this가 가리키는 값</th>
</tr>
</thead>
<tbody><tr>
<td align="center">일반 함수로서 호출</td>
<td align="center">전역 객체</td>
</tr>
<tr>
<td align="center">메소드로서 호출</td>
<td align="center">메소드를 호출한 객체</td>
</tr>
<tr>
<td align="center">생성자 함수로서 호출</td>
<td align="center">생성자 함수가 (미래에) 생성할 인스턴스</td>
</tr>
</tbody></table>
<ul>
<li>new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.</li>
<li>new 연산자와 함께 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.</li>
</ul>
<h2 id="2-3-내부-메소드-Call-과-Construct"><a href="#2-3-내부-메소드-Call-과-Construct" class="headerlink" title="2-3. 내부 메소드 [[Call]] 과 [[Construct]]"></a>2-3. 내부 메소드 [[Call]] 과 [[Construct]]</h2><ul>
<li><p>함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다.</p>
</li>
<li><p>new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다.</p>
</li>
<li><p>함수는 객체이므로 일반 객체(Ordinary object)와 동일하게 동작할 수 있다.</p>
</li>
<li><p>함수 객체는 일반 객체의 내부 슬롯과 내부 메소드를 모두 가지고 있다.</p>
</li>
<li><p>내부 메소드 <code>[[Call]]</code>을 갖는 함수객체를 callable 이라 한다.</p>
</li>
<li><p>내부 메소드인 <code>[[Construct]]</code> 를 갖는 함수 객체를 constructor, <code>[[Construct]]</code> 를 갖지 않는 함수 객체를 non-constructor라고 부른다.</p>
</li>
<li><p>callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다.</p>
</li>
<li><p>생성자 함수로서 호출할 수 있다는 것은 new 연산자(또는 super연산자)와 함께 호출하는 것을 의미한다.</p>
</li>
<li><p>함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 <code>[[Call]]</code>가 호출되고 new 연산자 (또는 super 연산자)와 함께 생성자 함수로서 호출되면 내부 메소드 <code>[[Construct]]</code>가 호출된다.</p>
</li>
<li><p>일반적인 함수로 호출되면 - <code>[[Call]]</code> - callable - 호출할 수 있는 객체 - 함수</p>
</li>
<li><p>new 연산자 (또는 super 연산자)와 함께 생성자 함수로서 호출되면 - <code>[[Construct]]</code> - constructor/non-constructor - 생성자 함수로서 호출할 수 있는 객체 - 생성자 함수</p>
</li>
</ul>
<ul>
<li>super 키워드 : ES6에서 도입된 클래스에서 부모 클래스를 참조 (this와 유사)할 때 또는 부모 클래스의 생성자(constructor)를 호출할 때 사용한다.</li>
</ul>
<ul>
<li>호출할 수 없는 객체는 함수 객체가 아니므로 함수로서 기능하는 객체, 즉 함수 객체는 반드시 callable 이여야 한다.</li>
<li>따라서 모든 함수 객체는 내부 메소드 <code>[[Call]]</code>을 갖고 있으므로 호출할 수 있다. 하지만 모든 함수 객체가 <code>[[Construct]]</code>를 갖지는 않는다.</li>
<li>다시말해, 함수 객체는 constructor일 수도 있고 non-constructor일 수 있다.</li>
<li>결론적으로 함수객체는 callable 이면서 constructor이거나 callable 이면서 non-constructor이다.</li>
<li>즉 모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.</li>
</ul>
<h2 id="2-4-constructor-와-non-constructor-의-구분"><a href="#2-4-constructor-와-non-constructor-의-구분" class="headerlink" title="2-4. constructor 와 non-constructor 의 구분"></a>2-4. constructor 와 non-constructor 의 구분</h2><ul>
<li>자바스크립트 엔진은 함수를 생성할 때, FunctionCreate라는 추상 연산(abstract operation)을 사용한다.</li>
</ul>
<ul>
<li>추상 연산 : ECMAScript 사양에서 내부 동작의 구현 알고리즘을 표현한 것이다. ECMAScript 사양에서 설명을 위해 사용되는 함수와 유사한 의사 코드라고 이해하도록 하자.</li>
</ul>
<ul>
<li>추상 연산 FunctionCreate는 함수 정의가 평가될 때 호출된다. 이 때 함수 정의 방식에 따라 FunctionCreate의 첫번째 매개변수 kind에 함수의 종류를 나타내는 문자열이 전달된다.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">구분</th>
<th align="center">함수의 종류를 나타내는 문자열</th>
</tr>
</thead>
<tbody><tr>
<td align="center">일반 함수 정의(함수 선언문, 함수 표현식)를 평가할 때</td>
<td align="center">Normal</td>
</tr>
<tr>
<td align="center">화살표 함수 정의를 평가할 때</td>
<td align="center">Arrow</td>
</tr>
<tr>
<td align="center">메소드 정의를 평가할 때</td>
<td align="center">Method</td>
</tr>
</tbody></table>
<ul>
<li><p>이 때 주의할 것은 ECMAScript 사양에서 “메소드 정의”로 인정하는 범위가 일반적인 메소드보다 좁다는 것이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 일반 함수 정의 : kind &#x3D; &#39;Normal&#39;</span><br><span class="line">function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">const bar &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 x에 할당된 것은 일반 함수 정의이다. 메소드 정의로 인정하지 않는다.</span><br><span class="line">const baz &#x3D; &#123;</span><br><span class="line">  x: function () &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 일반 함수로 정의된 함수만이 constructor이다.</span><br><span class="line">  foo();</span><br><span class="line">new bar();</span><br><span class="line">new baz.x(); &#x2F;&#x2F; 셋 다 OK</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 화살표 함수 정의 : kind &#x3D; &#39;Arrow&#39;</span><br><span class="line">const arrow &#x3D; () &#x3D;&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; new arrow(); &#x2F;&#x2F; TypeError: arrow is not a constructor</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 메소드 정의 : kind &#x3D; &#39;Method&#39;</span><br><span class="line">&#x2F;&#x2F; ES6의 메소드 축약 표현만을 메소드 정의로 인정한다.</span><br><span class="line">const obj &#x3D; &#123;</span><br><span class="line">  x() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; new obj.x(); &#x2F;&#x2F; TypeError: obj.x is not a constructor</span><br></pre></td></tr></table></figure></li>
<li><p>프로퍼티 값인 함수는 모두 메소드로 통칭한다. 하지만 ECMAScript 사양에서 ‘메소드 정의’란 ES6의 메소드 축약 표현만을 의미한다.</p>
</li>
<li><p>함수가 어디에 할당되어 있는지에 따라 메소드 정의인지를 판단하는 것이 아니라 함수 정의 방식에 따라 함수의 종류를 구분한다.</p>
</li>
<li><p>일반 함수로 정의된 함수만이 constructor이다.</p>
</li>
<li><p>Arrow, Method인 함수는 non-constructor가 된다.</p>
</li>
<li><p>즉, 일반 함수로 정의된 함수만이 생성자 함수로서 호출될 수 있다.</p>
</li>
<li><p>함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 <code>[[Call]]</code> 가 호출되고 new 연산자 또는 super 연산자와 함께 생성자 함수로서 호출되면 내부 메소드 <code>[[Construct]]</code>가 호출된다.</p>
</li>
<li><p>non-construct인 함수 객체는 내부 메소드 <code>[[Construct]]</code>를 갖지 않는다. 따라서 non-constructor 인 함수 객체를 생성자 함수로서 호출하면 에러가 발생한다.</p>
</li>
<li><p>Arrow, Method - 화살표함수, 축약표현을 한 메소드정의 함수를 생성자 함수로 호출하면 에러가 발생하고,</p>
</li>
<li><p>정의하지 않은 일반 함수를 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다.</p>
</li>
<li><p>따라서 생성자 함수는 첫문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다.</p>
</li>
</ul>
<h2 id="2-5-생성자-함수의-인스턴스-생성-과정"><a href="#2-5-생성자-함수의-인스턴스-생성-과정" class="headerlink" title="2-5. 생성자 함수의 인스턴스 생성 과정"></a>2-5. 생성자 함수의 인스턴스 생성 과정</h2><ul>
<li>생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당) 하는 것이다.</li>
<li>생성자 함수가 인스턴스를 생성하는 것은 필수고, 생성된 인스턴스를 초기화 하는 것은 옵션이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  &#x2F;&#x2F; 인스턴스 초기화</span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getDiameter &#x3D; function () &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스 생성</span><br><span class="line">const circle1 &#x3D; new Circle(5);</span><br><span class="line"></span><br><span class="line">console.log(circle1); &#x2F;&#x2F; Circle &#123; radius: 5, getDiameter: [Function (anonymous)] &#125;</span><br><span class="line">console.log(circle1.radius); &#x2F;&#x2F; 5</span><br><span class="line">console.log(circle1.getDiameter()); &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<ul>
<li><p>생성자 함수 내부의 코드를 살펴보면 this에 프로퍼티를 추가하고 필요에 따라 인수로 전달된 초기값을 프로퍼티 값으로 할당한다. 하지만 인스턴스를 생성하고 반환하는 코드는 보이지 않는다.</p>
</li>
<li><p>자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다.</p>
</li>
<li><p>new 연산자와 함께 생성자 함수가 호출되면 자바스크립트 엔진은 아래와 같은 과정을 거쳐 인스턴스를 생성하고 인스턴스를 초기화 한 후, 인스턴스를 반환한다.</p>
</li>
</ul>
<h4 id="1-인스턴스-생성과-this-바인딩"><a href="#1-인스턴스-생성과-this-바인딩" class="headerlink" title="1. 인스턴스 생성과 this 바인딩"></a>1. 인스턴스 생성과 this 바인딩</h4><ul>
<li>암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 생성자 함수가 생성한 인스턴스이다.</li>
<li>그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩된다.</li>
<li>생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다.</li>
</ul>
<ul>
<li>바인딩 (binding) : 식별자와 값을 연결하는 과정을 의미한다.<br>예 ) 변수는 할당에 의해 값이 바인딩 된다.</li>
</ul>
<h4 id="2-인스턴스-초기화"><a href="#2-인스턴스-초기화" class="headerlink" title="2. 인스턴스 초기화"></a>2. 인스턴스 초기화</h4><ul>
<li>생성자 함수에 기술되어 있는 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.</li>
<li>this에 바인딩되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다. 이 처리는 개발자가 기술한다.</li>
</ul>
<h4 id="3-인스턴스-반환"><a href="#3-인스턴스-반환" class="headerlink" title="3. 인스턴스 반환"></a>3. 인스턴스 반환</h4><ul>
<li>생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 인스턴스 생성과 this 바인딩</span><br><span class="line"></span><br><span class="line">function Circle2(radius) &#123;</span><br><span class="line">  &#x2F;&#x2F; 1. 암묵적으로 빈 객체가 생성되고 this에 바인딩 된다.</span><br><span class="line">  console.log(this); &#x2F;&#x2F; Circle2 &#123;&#125;</span><br><span class="line"></span><br><span class="line">  console.log(Object.getPrototypeOf(this) &#x3D;&#x3D;&#x3D; Circle2.prototype); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 2. this에 바인딩되어 있는 인스턴스를 초기화 한다.</span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getDiameter &#x3D; function () &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 3. 완성된 인스턴스가 바인딩 된 this가 암묵적으로 반환된다.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스 생성. Circle2 생성자 함수는 암묵적으로 this를 반환한다.</span><br><span class="line">const circle3 &#x3D; new Circle2(1);</span><br><span class="line">console.log(circle3);</span><br><span class="line">&#x2F;&#x2F; Circle2 &#123; radius: 1, getDiameter: [Function (anonymous)] &#125;</span><br></pre></td></tr></table></figure></li>
<li>만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return문에 명시된 객체가 반환된다.</li>
<li>하지만 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.</li>
<li>생성자 함수 내부에서 return 문을 반드시 생략해야 한다.</li>
</ul>
<h2 id="2-6-new-연산자"><a href="#2-6-new-연산자" class="headerlink" title="2-6. new 연산자"></a>2-6. new 연산자</h2><ul>
<li>일반 함수와 생성자 함수에 특별한 형식적 차이는 없다.</li>
<li>new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다.</li>
<li>단, new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor 이여야 한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; new 연산자</span><br><span class="line">&#x2F;&#x2F; 생성자 함수로서 정의하지 않은 일반 함수</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출</span><br><span class="line">let inst &#x3D; new add();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수가 객체를 반환하지 않았으므로 반환문이 무시된다.</span><br><span class="line">&#x2F;&#x2F; 따라서 빈 객체가 생성되어 반환된다.</span><br><span class="line">console.log(inst); &#x2F;&#x2F; add &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체를 반환하는 일반 함수</span><br><span class="line">function createUser(name, role) &#123;</span><br><span class="line">  return &#123; name, role &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출</span><br><span class="line">inst &#x3D; new createUser(&#39;Mare&#39;, &#39;admin&#39;);</span><br><span class="line">&#x2F;&#x2F; 함수가 생성된 객체를 반환한다.</span><br><span class="line">console.log(inst); &#x2F;&#x2F; &#123; name: &#39;Mare&#39;, role: &#39;admin&#39; &#125;</span><br></pre></td></tr></table></figure></li>
<li>반대로 new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출된다.</li>
<li>다시 말해, 함수 객체의 내부 메소드 <code>[[Construct]]</code>가 호출되는 것이 아니라 <code>[[Call]]</code>이 호출된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getDiameter &#x3D; function () &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; new 연산자 없이 생성자 함수 호출하면 일반 함수로서 호출된다.</span><br><span class="line">const circle &#x3D; Circle(5);</span><br><span class="line">console.log(circle); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 일반 함수 내부의 this는 전역 객체 window를 가리킨다.</span><br><span class="line">console.log(radius); &#x2F;&#x2F; 5</span><br><span class="line">console.log(getDiameter()); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;circle.getDiameter(); &#x2F;&#x2F; TypeError: Cannot read property &#39;getDiameter&#39; of undefined</span><br></pre></td></tr></table></figure>
<p>(왜 radius랑 getDiameter만 호출해도 값이 나오는지 이미 객체가 생성되어있는것인지)</p>
<ul>
<li><p>Circle 함수를 new 연산자와 함께 생성자 함수로서 호출하면 함수 내부의 this는 Circle 생성자 함수가 생성할 인스턴스를 가리킨다. 하지만 Circle 함수를 일반적인 함수로서 호출하면 함수 내부의 this는 전역 객체 window를 가리킨다.</p>
</li>
<li><p>위 예제의 Circle 함수는 일반 함수로서 호출되었으므로 Circle 함수 내부의 this는 전역 객체 window를 가리킨다. 따라서 radius 프로퍼티와 getDiameter 메소드는 전역 객체의 프로퍼티와 메소드가 된다.</p>
</li>
<li><p>일반 함수와 생성자 함수에 특별한 형식적 차이는 없다.</p>
</li>
<li><p>생성자 함수는 일반적으로 첫문자를 대문자로 기술하는 파스칼케이스로 명명하여 일반함수와 구별할 수 있도록 노력한다.</p>
</li>
</ul>
<h2 id="2-7-new-target"><a href="#2-7-new-target" class="headerlink" title="2-7. new.target"></a>2-7. new.target</h2><ul>
<li>new.target 은 this와 유사하게 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타프로퍼티(meta property)라고 부른다. (IE는 지원하지 않음)</li>
<li>함수 내부에서 new.target을 사용하면 new 연산자와 함께 함수가 호출되었는지 확인할 수 있다. 함수가 new 연산자와 함께 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 호출된 함수 내부의 new.target은 undefined 이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; new.target</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  &#x2F;&#x2F; 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined 이다.</span><br><span class="line">  if (!new.target) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다.</span><br><span class="line">    return new Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getDiameter &#x3D; function () &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.</span><br><span class="line">const circle &#x3D; Circle(5);</span><br><span class="line">console.log(circle.getDiameter());</span><br><span class="line">console.log(circle);</span><br></pre></td></tr></table></figure>

<ul>
<li>스코프 세이프 생성자 (Scope-Safe Constructor) 패턴</li>
</ul>
<ul>
<li>new.target을 사용할 수 없는 상황이라면(IE) 스코프 세이프 생성자 패턴을 사용할 수 있다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Scope-Safe Constructor Pattern</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고</span><br><span class="line">  &#x2F;&#x2F; this에 바인딩한다. 이 때 this와 Circle은 프로토타입에 의해 연결된다.</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다.</span><br><span class="line">  &#x2F;&#x2F; 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다.</span><br><span class="line">  if (!(this instanceof Circle)) &#123;</span><br><span class="line">    &#x2F;&#x2F; new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다.</span><br><span class="line">    return new Circle(radius);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getDiameter &#x3D; function () &#123;</span><br><span class="line">    return 2 * this.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.</span><br><span class="line">const circle &#x3D; Circle(5);</span><br><span class="line">console.log(circle.getDiameter());</span><br></pre></td></tr></table></figure></li>
<li>new 연산자와 함께 생성자 함수에 의해 생성된 객체(인스턴스)는 프로토타입에 의해 생성자 함수와 연결된다. 이를 이용해 new 연산자와 함께 호출되었는지를 확인할 수 있다.</li>
<li>대부분의 빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등)는 new 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다.</li>
<li>예를 들어, Object 또는 Function 생성자 함수는 new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 빌트인 생성자 함수 new 연산자 없이 호출하기</span><br><span class="line">let obj &#x3D; new Object();</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj &#x3D; Object();</span><br><span class="line">console.log(obj); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">let f &#x3D; new Function(&#39;x&#39;, &#39;return x ** x&#39;);</span><br><span class="line">console.log(f); &#x2F;&#x2F; [Function: anonymous]</span><br><span class="line"></span><br><span class="line">f &#x3D; Function(&#39;x&#39;, &#39;return x ** x&#39;);</span><br><span class="line">console.log(f); &#x2F;&#x2F; [Function: anonymous]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 하지만 String 생성자 함수는 new 연산자와 함께 호출했을 때 String 객체를 생성하여</span><br><span class="line">&#x2F;&#x2F; 반환하지만 new 연산자 없이 호출하면 문자열 리터럴을 반환한다.</span><br><span class="line">&#x2F;&#x2F; 즉, 문자열로 타입을 변환한다.</span><br><span class="line"></span><br><span class="line">let s &#x3D; new String(&#39;abc&#39;);</span><br><span class="line">console.log(s); &#x2F;&#x2F; [String: &#39;abc&#39;]</span><br><span class="line"></span><br><span class="line">s &#x3D; String(&#39;abc&#39;);</span><br><span class="line">console.log(s); &#x2F;&#x2F; abc</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-property-definition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-property-definition/" class="post-title-link" itemprop="url">javascript-property-definition</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-02 13:55:05" itemprop="dateCreated datePublished" datetime="2020-03-02T13:55:05+09:00">2020-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-03 16:14:26" itemprop="dateModified" datetime="2020-03-03T16:14:26+09:00">2020-03-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><h2 id="1-내부-슬롯과-내부-메소드"><a href="#1-내부-슬롯과-내부-메소드" class="headerlink" title="1. 내부 슬롯과 내부 메소드"></a>1. 내부 슬롯과 내부 메소드</h2><ul>
<li></li>
</ul>
<h3 id="3-1-데이터-프로퍼티"><a href="#3-1-데이터-프로퍼티" class="headerlink" title="3-1. 데이터 프로퍼티"></a>3-1. 데이터 프로퍼티</h3><ul>
<li>자바스크립트 엔진이 프로퍼티를 생성할 때, 기본값으로 자동 정의된다.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">프로퍼티 어트리뷰트</th>
<th align="center">프로퍼티 디스크립터 객체의 프로퍼티</th>
<th align="center">설명</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>[[Value]]</code></td>
<td align="center">value</td>
<td align="center">* 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값.<br> * 프로퍼티 키로 프로퍼티 값을 저장하면 <code>[[Value]]</code> 에 값을 저장한다. <br> 이 때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 <code>[[Value]]</code> 에 값을 저장한다.</td>
</tr>
<tr>
<td align="center"><code>[[Writable]]</code></td>
<td align="center">writable</td>
<td align="center">* 프로퍼티 값의 변경 가능 여부.<br> * 불리언 값<br> * false인 경우, 값을 변경할 수 없는 읽기 전용 프로퍼티.</td>
</tr>
<tr>
<td align="center"><code>[[Enumerable]]</code></td>
<td align="center">enumerable</td>
<td align="center">* 프로퍼티의 열거 가능 여부.<br> * 불리언 값<br> * false인 경우, for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다.</td>
</tr>
<tr>
<td align="center"><code>[[Configurable]]</code></td>
<td align="center">configurable</td>
<td align="center">* 프로퍼티의 재정의 가능 여부.<br> * 불리언 값<br> * false인 경우, 프로퍼티의 삭제, 값의 변경이 금지된다.<br> * 단, true인 경우, <code>[[Value]]</code>,<code>[[Writable]]</code> 을 변경하는 것은 허용된다.</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 프로퍼티 어트리뷰트 예제</span><br><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(person, &#39;name&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#123; value: &#39;Lee&#39;, writable: true, enumerable: true, configurable: true &#125;</span><br><span class="line"></span><br><span class="line">person.age &#x3D; 20;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#123;</span><br><span class="line">&#x2F;&#x2F;  name: &#123; value: &#39;Lee&#39;,writable: true,enumerable: true,configurable: true&#125;,</span><br><span class="line">&#x2F;&#x2F;  age: &#123; value: 20, writable: true, enumerable: true, configurable: true &#125;</span><br><span class="line">&#x2F;&#x2F;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>프로퍼티가 생성될 때 <code>[[Value]]</code> 의 값은 프로퍼티 값으로 초기화되며 <code>[[Writable]]</code>,<code>[[Enumerable]]</code>,<code>[[Configurable]]</code> 의 기본값 true로 초기화된다. 프로퍼티를 동적으로 추가하여도 마찬가지.</li>
</ul>
<h3 id="3-2-접근자-프로퍼티"><a href="#3-2-접근자-프로퍼티" class="headerlink" title="3-2. 접근자 프로퍼티"></a>3-2. 접근자 프로퍼티</h3><ul>
<li>자체적으로는 값을 갖지 않고, 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">프로퍼티 어트리뷰트</th>
<th align="center">프로퍼티 디스크립터 객체의 프로퍼티</th>
<th align="center">설명</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>[[Get]]</code></td>
<td align="center">get</td>
<td align="center">* 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 <code>[[Get]]</code>의 값, 즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</td>
</tr>
<tr>
<td align="center"><code>[[Set]]</code></td>
<td align="center">set</td>
<td align="center">* 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 <code>[[Set]]</code>의 값, 즉 setter함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</td>
</tr>
<tr>
<td align="center"><code>[[Enumerable]]</code></td>
<td align="center">enumerable</td>
<td align="center">* 데이터 프로퍼티의 <code>[[Enumerable]]</code>와 같다.</td>
</tr>
<tr>
<td align="center"><code>[[Configurable]]</code></td>
<td align="center">configurable</td>
<td align="center">* 데이터 프로퍼티의 <code>[[Configurable]]</code>와 같다.</td>
</tr>
</tbody></table>
<ul>
<li>접근자 함수는 getter/setter 함수라고도 부른다. 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다.<br>(수업시간에 이해해야 하는 부분)</li>
<li>메소드 앞에 get, set 이 붙은 메소드가 있는데 이것들이 바로 getter/setter 함수.</li>
<li>접근자 프로퍼티는 자체적으로 값을 가지지 않으며 다만 데이터 프로퍼티 값을 읽거나 저장할 때 관여할 뿐이다.</li>
<li>접근자 프로퍼티로 프로퍼티 값에 접근하면 <code>[[Get]]</code> 내부 메소드가 호출되어 아래와 같이 동작한다.<ol>
<li>프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 문자열 또는 심볼이어야 한다.</li>
<li>프로토타입 체인에서 프로퍼티를 검색한다.</li>
<li>검색된 프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다.</li>
<li>접근자 프로퍼티의 프로퍼티 어트리뷰트 <code>[[Get]]</code>의 값, 즉 getter 함수를 호출하여 그 결과를 반환한다. Object.getOwnPropertyDescriptor 메소드가 반환하는 프로퍼티 디스크립터 객체의 get 프로퍼티 값과 같다.</li>
</ol>
</li>
</ul>
<h2 id="4-프로퍼티-정의"><a href="#4-프로퍼티-정의" class="headerlink" title="4. 프로퍼티 정의"></a>4. 프로퍼티 정의</h2><ul>
<li>새로운 프로퍼티를 추가하면서, 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.</li>
<li>프로퍼티 값을 갱신 가능하도록 할 것인지, 프로퍼티를 열거 가능하도록 할 것인지, 프로퍼티를 재정의 가능하도록 할 것인지 정의할 수 있다.</li>
<li>Object.defineProperty 메소드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수는 객체의 참조와 데이터 프로퍼티의 키인 문자열 그리고 프로퍼티 디스크립터 객체를 전달한다.</li>
</ul>
<h2 id="5-객체-변경-방지"><a href="#5-객체-변경-방지" class="headerlink" title="5. 객체 변경 방지"></a>5. 객체 변경 방지</h2><ul>
<li>객체는 변경 가능한 값이므로 재할당없이 직접 변경이 가능하다.</li>
<li>프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티의 값을 갱신할 수 있으며 Object.defineProperty 또는 Object.defineProperties 메소드를 사용하여 프로퍼티 어트리뷰트를 재정의할 수도 있다.</li>
<li>객체의 변경을 방지할 수 있는 다양한 메소드를 제공한다.</li>
<li>객체 변경 방지 메소드들은 변경을 금지하는 강도가 다르다.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">구분</th>
<th align="center">메소드</th>
<th align="center">프로퍼티 값 읽기</th>
<th align="center">프로퍼티 값 쓰기</th>
<th align="center">프로퍼티 삭제</th>
<th align="center">프로퍼티 추가</th>
<th align="center">프로퍼티 어트리뷰트 재정의</th>
</tr>
</thead>
<tbody><tr>
<td align="center">객체 확장 금지</td>
<td align="center">Object.preventExtensions</td>
<td align="center">○</td>
<td align="center">○</td>
<td align="center">○</td>
<td align="center">✕</td>
<td align="center">○</td>
</tr>
<tr>
<td align="center">객체 밀봉</td>
<td align="center">Object.seal</td>
<td align="center">○</td>
<td align="center">○</td>
<td align="center">✕</td>
<td align="center">✕</td>
<td align="center">✕</td>
</tr>
<tr>
<td align="center">객체 동결</td>
<td align="center">Object.freeze</td>
<td align="center">○</td>
<td align="center">✕</td>
<td align="center">✕</td>
<td align="center">✕</td>
<td align="center">✕</td>
</tr>
</tbody></table>
<h3 id="5-1-객체-확장-금지"><a href="#5-1-객체-확장-금지" class="headerlink" title="5-1. 객체 확장 금지"></a>5-1. 객체 확장 금지</h3><ul>
<li>Object.preventExtensions 메소드는 객체의 확장을 금지한다.</li>
<li>확장이 금지된 객체는 프로퍼티 추가가 금지된다.</li>
<li>프로퍼티 동적 추가와 Object.defineProperty 메소드로 추가할 수 있다.</li>
<li>확장이 금지된 객체인지 여부는 Object.isExtensible 메소드로 확인 할 수 있다.</li>
</ul>
<h3 id="5-2-객체-밀봉"><a href="#5-2-객체-밀봉" class="headerlink" title="5-2. 객체 밀봉"></a>5-2. 객체 밀봉</h3><ul>
<li>Object.seal 메소드는 객체를 밀봉한다.</li>
<li>밀봉된 객체는 읽기와 쓰기만 가능하게 된다.</li>
<li>밀봉된 객체인지 여부는 Object.isSealed 메소드로 확인 할 수 있다.</li>
</ul>
<h3 id="5-3-객체-동결"><a href="#5-3-객체-동결" class="headerlink" title="5-3. 객체 동결"></a>5-3. 객체 동결</h3><ul>
<li>Object.freeze 메소드는 객체를 동결한다.</li>
<li>동결된 객체는 읽기만 가능하게 된다.</li>
<li>동결된 객체인지 여부는 Object.isFrozen 메소드로 확인 할 수 있다.</li>
</ul>
<h3 id="5-4-불변-객체"><a href="#5-4-불변-객체" class="headerlink" title="5-4. 불변 객체"></a>5-4. 불변 객체</h3><ul>
<li>변경 방지 메소드들은 얕은 변경 방지(Shallow only)로 직속 프로퍼티만 변경이 방지되고, 중첩 객체까지는 영향을 주지는 못하다.</li>
<li>객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변객체를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메소드를 호출해야 한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-block-level-scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-block-level-scope/" class="post-title-link" itemprop="url">javascript-block-level-scope</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-02 00:03:55 / Modified: 13:33:48" itemprop="dateCreated datePublished" datetime="2020-03-02T00:03:55+09:00">2020-03-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-let-const-와-블록-레벨-스코프"><a href="#1-let-const-와-블록-레벨-스코프" class="headerlink" title="1. let, const 와 블록 레벨 스코프"></a>1. let, const 와 블록 레벨 스코프</h1><h2 id="1-var-키워드로-선언한-변수의-문제점"><a href="#1-var-키워드로-선언한-변수의-문제점" class="headerlink" title="1. var 키워드로 선언한 변수의 문제점"></a>1. var 키워드로 선언한 변수의 문제점</h2><h3 id="1-1-변수-중복-선언-허용"><a href="#1-1-변수-중복-선언-허용" class="headerlink" title="1-1. 변수 중복 선언 허용"></a>1-1. 변수 중복 선언 허용</h3><ul>
<li>var 키워드로 선언한 변수는 중복 선언 가능.</li>
<li>에러는 발생하지 않고, 아래 변수 선언은 var 가 없는 것처럼 동작해 재할당되어 변수 값이 변경된다.</li>
</ul>
<h3 id="1-2-함수-레벨-스코프"><a href="#1-2-함수-레벨-스코프" class="headerlink" title="1-2. 함수 레벨 스코프"></a>1-2. 함수 레벨 스코프</h3><ul>
<li>var 키워드로 선언한 변수는 오로지 함수 블록만을 지역 스코프로 인정.</li>
<li>함수 외부에서 var 키워드로 선언한 변수는 코드 블록내에서 선언하여도 모두 전역 변수가 된다.</li>
<li>전역 변수를 남발할 가능성을 높이고, 전역 변수가 중복 선언 되는 경우가 발생한다.</li>
</ul>
<h3 id="1-3-변수-호이스팅"><a href="#1-3-변수-호이스팅" class="headerlink" title="1-3. 변수 호이스팅"></a>1-3. 변수 호이스팅</h3><ul>
<li>var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다.</li>
<li>변수 선언문 이전에 참조하면 에러를 발생시키진 않으나 흐름에도 맞지 않고, 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.</li>
</ul>
<h2 id="2-let-키워드"><a href="#2-let-키워드" class="headerlink" title="2. let 키워드"></a>2. let 키워드</h2><h3 id="2-1-변수-중복-선언-금지"><a href="#2-1-변수-중복-선언-금지" class="headerlink" title="2-1. 변수 중복 선언 금지"></a>2-1. 변수 중복 선언 금지</h3><ul>
<li>let 키워드로 동일한 이름을 갖는 변수를 중복 선언하면 SyntaxError 가 발생한다.<h3 id="2-2-블록-레벨-스코프"><a href="#2-2-블록-레벨-스코프" class="headerlink" title="2-2. 블록 레벨 스코프"></a>2-2. 블록 레벨 스코프</h3></li>
<li>let 키워드로 선언한 변수는 모든 코드 블록 (함수, if문, for문, while문, try/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.<h3 id="2-3-변수-호이스팅"><a href="#2-3-변수-호이스팅" class="headerlink" title="2-3. 변수 호이스팅"></a>2-3. 변수 호이스팅</h3></li>
<li>let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것 처럼 동작한다. </li>
<li>변수 선언문 전에 참조 &gt; Reference Error</li>
<li>변수 선언문에서 초기화 &gt; undefined</li>
<li>변수 할당문에서 할당 &gt; 할당값</li>
<li>일시적 사각지대 (Temporal Dead Zone; TDZ)<br>: 스코프의 시작지점부터 초기화 시작지점까지의 구간. 변수를 참조할 수 없다.</li>
<li>let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 보이지만 발생한다. (let, const, class 모두)<h3 id="2-4-전역-객체와-let"><a href="#2-4-전역-객체와-let" class="headerlink" title="2-4. 전역 객체와 let"></a>2-4. 전역 객체와 let</h3></li>
<li>전역객체 : 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다. 클라이언트 사이드 환경(브라우저):window, 서버사이드 환경(Node.js):global.</li>
<li>var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이다.</li>
<li>전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</li>
<li>암묵적 전역은 전역 객체의 프로퍼티이다.</li>
<li>함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이다.</li>
<li>전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</li>
<li>let 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다. 보이지 않는 개념적인 블록내에 존재하게 된다.</li>
</ul>
<h2 id="3-const-키워드"><a href="#3-const-키워드" class="headerlink" title="3. const 키워드"></a>3. const 키워드</h2><ul>
<li>상수를 선언하기 위해 사용한다.</li>
<li>하지만 반드시 상수만을 위해 사용하지는 않는다.<h3 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3-1. 선언과 초기화"></a>3-1. 선언과 초기화</h3></li>
<li>const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다. 그렇지 않으면 SyntaxError.</li>
<li>let 키워드로 선언한 변수와 마찬가지로 블록레벨 스코프를 가지며 변수 호이스팅이 발생하지 않는 것처럼 동작한다.<h3 id="3-2-재할당-금지"><a href="#3-2-재할당-금지" class="headerlink" title="3-2. 재할당 금지"></a>3-2. 재할당 금지</h3></li>
<li>const 키워드로 선언한 변수는 재할당이 금지된다.</li>
<li>TypeError.<h3 id="3-3-상수"><a href="#3-3-상수" class="headerlink" title="3-3. 상수"></a>3-3. 상수</h3></li>
<li>원시값을 할당하면, 변수값을 변경할 수 없다.</li>
<li>재할당이 금지된 변수. 재할당 금지.</li>
<li>상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 한다.</li>
<li>일반적으로 상수의 이름은 대문자로 선언하여 상수임을 명확히 나타낸다.</li>
<li>여러 단어로 이루어진 경우에는 언더스코어(_)로 구분하여 스네이크 케이스로 표현하는 것이 일반적이다.<h3 id="3-4-const-키워드와-객체"><a href="#3-4-const-키워드와-객체" class="headerlink" title="3-4. const 키워드와 객체"></a>3-4. const 키워드와 객체</h3></li>
<li>객체를 할당한 경우, 값을 변경할 수 있다.</li>
<li>const 키워드는 재할당을 금지할 뿐 불변을 의미하지는 않는다.</li>
<li>새로운 값을 재할당 하는 것은 불가능하지만, 객체의 내용 (프로퍼티의 추가, 삭제, 프로퍼티 값의 변경)을 변경하는 것은 가능하다.</li>
<li>객체의 내용이 변경되더라도 변수에 할당된 참조값은 변경되지 않는다.<h2 id="4-var-vs-let-vs-const"><a href="#4-var-vs-let-vs-const" class="headerlink" title="4. var vs. let vs. const"></a>4. var vs. let vs. const</h2></li>
<li>변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다.</li>
<li>원시 값의 경우, 가급적 상수를 사용하는 편이 좋다.</li>
<li>객체를 재할당하는 경우는 흔하지 않으므로 const 키워드를 사용해 의도치 않는 재할당을 방지해주면 된다.<ul>
<li>ES6 를 사용한다면 var 키워드는 사용하지 않는다.</li>
<li>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.</li>
<li>변경이 발생하지 않고 읽기전용으로 사용하는 (재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.</li>
</ul>
</li>
<li>const 를 기본으로 사용하고, 재할당이 꼭 필요한 곳에만 let으로 변경한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/02/javascript-global-variable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/javascript-global-variable/" class="post-title-link" itemprop="url">javascript-global-variable</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-27 20:42:21 / Modified: 21:53:59" itemprop="dateCreated datePublished" datetime="2020-02-27T20:42:21+09:00">2020-02-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="전역-변수의-문제점"><a href="#전역-변수의-문제점" class="headerlink" title="전역 변수의 문제점"></a>전역 변수의 문제점</h1><h2 id="1-변수의-생명-주기"><a href="#1-변수의-생명-주기" class="headerlink" title="1. 변수의 생명 주기"></a>1. 변수의 생명 주기</h2><h3 id="1-1-지역-변수의-생명-주기"><a href="#1-1-지역-변수의-생명-주기" class="headerlink" title="1-1. 지역 변수의 생명 주기"></a>1-1. 지역 변수의 생명 주기</h3><ul>
<li>런타임 이전 단계에 변수 선언이 되는 것은 전역 변수 한정이다.</li>
<li>함수 내부에서 선언된 지역 변수는 함수가 호출되어 실행되는 동안에만 유효하다.</li>
<li>지역 변수의 생명주기는 함수의 생명주기와 일치한다.</li>
<li>호이스팅은 스코프를 단위로 동작한다.</li>
</ul>
<h3 id="1-2-전역-변수의-생명-주기"><a href="#1-2-전역-변수의-생명-주기" class="headerlink" title="1-2. 전역 변수의 생명 주기"></a>1-2. 전역 변수의 생명 주기</h3><ul>
<li>전역 코드는 코드가 로드되자마자 곧바로 해석되고 실행된다.</li>
</ul>
<ul>
<li>전역 객체 Grobal Object : 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체. 클라이언트 사이드 환경(브라우저) 에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다.</li>
</ul>
<ul>
<li>var 키워드로 선언한 전역 변수는 전역 객체 window 의 프로퍼티가 된다. 이 전역 변수는 웹페이지를 종료할 때까지 유효하다. 전역 변수의 생명주기가 전역 객체의 생명주기와 일치한다.</li>
</ul>
<h2 id="2-전역-변수의-문제점"><a href="#2-전역-변수의-문제점" class="headerlink" title="2. 전역 변수의 문제점"></a>2. 전역 변수의 문제점</h2><h3 id="암묵적-결합"><a href="#암묵적-결합" class="headerlink" title="+ 암묵적 결합"></a>+ 암묵적 결합</h3><ul>
<li>전역 변수를 선언하면 어디에서든지 참조하고 변경할 수 있는 암묵적 결합을 허용하므로, 변수의 유효범위가 클수록 가독성이 나빠지고 상태가 변경될 수 있는 위험성도 높아진다.</li>
</ul>
<h3 id="긴-생명-주기"><a href="#긴-생명-주기" class="headerlink" title="+ 긴 생명 주기"></a>+ 긴 생명 주기</h3><ul>
<li>전역 변수는 생명주기가 길다. 메모리 리소스도 오랜기간 소비하고, 상태를 변경할 수 있는 시간도 길고, 참조에 의해 상태가 변경될 기회도 많다.</li>
<li>var 키워드는 변수의 중복 선언을 허용하므로 전역변수는 변수 이름이 중복되어서 의도치 않은 재할당이 이루어 질 수 있다.</li>
</ul>
<h3 id="스코프-체인-상에서-종점에-존재"><a href="#스코프-체인-상에서-종점에-존재" class="headerlink" title="+ 스코프 체인 상에서 종점에 존재"></a>+ 스코프 체인 상에서 종점에 존재</h3><ul>
<li>변수를 검색할 때 전역변수가 가장 마지막에 검색되어 검색 속도가 가장 느리다.<br>(수업시간에 더 이해할 것)</li>
</ul>
<h3 id="네임-스페이스-오염"><a href="#네임-스페이스-오염" class="headerlink" title="+ 네임 스페이스 오염"></a>+ 네임 스페이스 오염</h3><ul>
<li>파일이 분리되어 있어도 하나의 전역 스코프를 공유하기 때문에 다른 파일 내에 동일한 이름의 변수나 함수가 같은 스코프내에 존재할 경우 예상치 못한 결과를 가져올 수 있다.</li>
</ul>
<h2 id="3-전역-변수-사용-억제-방법"><a href="#3-전역-변수-사용-억제-방법" class="headerlink" title="3. 전역 변수 사용 억제 방법"></a>3. 전역 변수 사용 억제 방법</h2><ul>
<li>전역 변수를 반드시 사용해야 할 이유가 없다면 지역변수를 사용해야 한다.</li>
<li>변수의 스코프는 좁을수록 좋다.</li>
</ul>
<h3 id="3-1-즉시-실행-함수"><a href="#3-1-즉시-실행-함수" class="headerlink" title="3-1. 즉시 실행 함수"></a>3-1. 즉시 실행 함수</h3><ul>
<li>즉시 실행 함수로 모든 코드를 감싸면 지역 변수가 된다.</li>
<li>라이브러리 등에 자주 사용된다.</li>
</ul>
<h3 id="3-2-네임-스페이스-객체"><a href="#3-2-네임-스페이스-객체" class="headerlink" title="3-2. 네임 스페이스 객체"></a>3-2. 네임 스페이스 객체</h3><ul>
<li>전역에 네임 스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법.</li>
<li>네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가하여 계층적으로 구성할 수도 있다.</li>
<li>식별자 충돌은 방지할 수 있으나, 네임스페이스 객체 자체가 전역 변수에 할당되므로 유용하지는 않다.</li>
</ul>
<h3 id="3-3-모듈-패턴"><a href="#3-3-모듈-패턴" class="headerlink" title="3-3. 모듈 패턴"></a>3-3. 모듈 패턴</h3><ul>
<li>클래스를 모방하여, 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.</li>
<li>클로저를 기반으로 동작한다.</li>
<li>전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다.</li>
<li>캡슐화 : 외부에 공개될 필요가 없는 정보를 외부에 노출시키지 않고 숨기는 것을 말하며 정보 은닉 이라고도 한다.</li>
<li>퍼블릭 멤버, 프라이빗 멤버.<br>(수업시간에 더 이해할 것)</li>
</ul>
<h3 id="3-4-ES6-모듈"><a href="#3-4-ES6-모듈" class="headerlink" title="3-4. ES6 모듈"></a>3-4. ES6 모듈</h3><ul>
<li>script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 모듈의 파일 확장자는 mjs를 권장한다.</li>
<li>구형브라우저에서는 동작하지 않으며, 트랜스 파일링이나 번들링이 필요하기 때문에 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/02/javascript-scope/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/javascript-scope/" class="post-title-link" itemprop="url">javascript - scope</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-26 17:15:58" itemprop="dateCreated datePublished" datetime="2020-02-26T17:15:58+09:00">2020-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-27 09:42:39" itemprop="dateModified" datetime="2020-02-27T09:42:39+09:00">2020-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-스코프"><a href="#1-스코프" class="headerlink" title="1. 스코프"></a>1. 스코프</h1><h2 id="1-스코프란"><a href="#1-스코프란" class="headerlink" title="1. 스코프란?"></a>1. 스코프란?</h2><ul>
<li>Scope, 유효범위.</li>
<li>모든 식별자 (변수 이름, 함수 이름, 클래스 이름 등) 는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다.</li>
<li>식별자가 유효한 범위.</li>
<li>자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지 결정 &gt; 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙.</li>
<li>컴퓨터의 디렉토리같은 개념.</li>
</ul>
<ul>
<li>var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용되고, 변수값이 재할당되어 변경되는 부작용을 발생시킴.</li>
</ul>
<h2 id="2-스코프의-종류"><a href="#2-스코프의-종류" class="headerlink" title="2. 스코프의 종류"></a>2. 스코프의 종류</h2><ul>
<li><p>전역 global : 코드의 가장 바깥 영역 / 전역 스코프 / 전역 변수</p>
</li>
<li><p>지역 local : 함수 몸체 내부 / 지역 스코프 / 지역 변수</p>
<h3 id="2-1-전역과-전역-스코프"><a href="#2-1-전역과-전역-스코프" class="headerlink" title="2-1. 전역과 전역 스코프"></a>2-1. 전역과 전역 스코프</h3><ul>
<li>전역 변수는 어디서든지 참조할 수 있다. = 함수 내부에서도 참조할 수 있다.</li>
</ul>
<h3 id="2-2-지역과-지역-스코프"><a href="#2-2-지역과-지역-스코프" class="headerlink" title="2-2. 지역과 지역 스코프"></a>2-2. 지역과 지역 스코프</h3><ul>
<li>지역 변수는 자신이 선언된 지역과 하위 지역(중첩)에서만 참조할 수 있다.</li>
<li>전역변수와 지역변수의 이름이 같을 때, 지역에서 그 변수를 참조하면 지역 내부에서 선언된 변수를 참조한다.</li>
</ul>
</li>
</ul>
<h2 id="3-스코프-체인"><a href="#3-스코프-체인" class="headerlink" title="3. 스코프 체인"></a>3. 스코프 체인</h2><ul>
<li><p>중첩 함수 : 함수 몸체 내부에서 정의한 함수</p>
</li>
<li><p>외부 함수 : 중첩 함수를 포함하는 함수</p>
</li>
<li><p>스코프는 함수의 중첩에 의해 계층적 구조를 갖는다.</p>
</li>
<li><p>모든 지역 스코프의 최상위 스코프는 전역 스코프.</p>
</li>
<li><p>스코프 체인 : 최상위 스코프 (전역 스코프) &gt; outer 지역 스코프 &gt; inner 지역 스코프</p>
</li>
<li><p>상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있다.</p>
<h3 id="3-1-스코프-체인에-의한-변수-검색"><a href="#3-1-스코프-체인에-의한-변수-검색" class="headerlink" title="3-1. 스코프 체인에 의한 변수 검색"></a>3-1. 스코프 체인에 의한 변수 검색</h3><ul>
<li>상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다.</li>
</ul>
<h3 id="3-2-스코프-체인에-의한-함수-검색"><a href="#3-2-스코프-체인에-의한-함수-검색" class="headerlink" title="3-2. 스코프 체인에 의한 함수 검색"></a>3-2. 스코프 체인에 의한 함수 검색</h3><ul>
<li>함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.</li>
<li>스코프 &gt; 식별자를 검색하는 규칙</li>
</ul>
</li>
</ul>
<h2 id="4-함수-레벨-스코프"><a href="#4-함수-레벨-스코프" class="headerlink" title="4. 함수 레벨 스코프"></a>4. 함수 레벨 스코프</h2><ul>
<li>코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다.</li>
<li>함수 레벨 스코프 : 함수의 코드 블록만을 지역스코프로 인정함.</li>
</ul>
<h2 id="5-렉시컬-스코프"><a href="#5-렉시컬-스코프" class="headerlink" title="5. 렉시컬 스코프"></a>5. 렉시컬 스코프</h2><ul>
<li>자바스크립트는 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/02/javascript-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/javascript-function/" class="post-title-link" itemprop="url">javascript - function</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-26 11:15:36 / Modified: 17:13:49" itemprop="dateCreated datePublished" datetime="2020-02-26T11:15:36+09:00">2020-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-함수"><a href="#1-함수" class="headerlink" title="1. 함수"></a>1. 함수</h1><h2 id="1-함수란"><a href="#1-함수란" class="headerlink" title="1. 함수란?"></a>1. 함수란?</h2><ul>
<li><p>함수를 검색해보니 函數 한자가 함 함자더라고 뭔가를 넣는데에 쓰는 이미지가 그려진다. 또는 품는다는 의미의 함. 그래서 함수를 설명할 때 박스를 그리고 파라미터&gt;함수&gt;결과 로 설명하는 듯.</p>
</li>
<li><p>하나의 명령으로 함수 안에 있는 여러가지 명령 = 문(statement)을 한 번에 실행할 수 있는 단위.</p>
</li>
<li><p>매개변수 = 파라미터 (parameter)</p>
</li>
<li><p>인수 (argument)</p>
<pre><code>- 사실 처음엔 인수랑 파라미터랑 같은 의미인 줄 알았는데 다시 공부하면서 확실히 차이점을 이해함.</code></pre></li>
<li><p>반환값 (return value)</p>
</li>
<li><p>식별자 = 함수 이름</p>
</li>
<li><p>함수 정의를 통해 함수를 만듦 &gt; 실행하려면 함수를 호출해야 함 &gt; 함수 호출 시 인수를 적어줌 &gt; 인수가 파라미터로 대입해서 들어감 &gt; 함수 안으로 들어가서 문을 일괄실행 &gt; 결과 = 반환값이 나옴.</p>
</li>
</ul>
<h2 id="2-함수의-사용-이유"><a href="#2-함수의-사용-이유" class="headerlink" title="2. 함수의 사용 이유"></a>2. 함수의 사용 이유</h2><ul>
<li>여러 반복되는 실행문을 함수로 정의해서 사용하면, 재사용에 있어서 유용하고, 유지보수에 효율적이고 가독성 측면에서도 좋다.</li>
</ul>
<h2 id="3-함수-리터럴"><a href="#3-함수-리터럴" class="headerlink" title="3. 함수 리터럴"></a>3. 함수 리터럴</h2><ul>
<li><p>객체 타입의 값. 따라서 객체 리터럴로 생성하는 것처럼 함수 리터럴로 생성 가능.<br>(변수에 함수 리터럴을 할당)</p>
</li>
<li><p>일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.</p>
</li>
<li><p>일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다. (수업시간에 확실히 이해한 후 내용 보충)</p>
<h4 id="함수-이름"><a href="#함수-이름" class="headerlink" title="+ 함수 이름"></a>+ 함수 이름</h4><ul>
<li>식별자, 함수 몸체 내에서만 참조할 수 있는 식별자</li>
<li>기명함수, 익명함수</li>
</ul>
<h4 id="매개변수-목록"><a href="#매개변수-목록" class="headerlink" title="+ 매개변수 목록"></a>+ 매개변수 목록</h4><ul>
<li>(매개변수1,매개변수2,매개변수3…)</li>
<li>함수호출문의 인수가 순서대로 매개변수에 할당됨. 순서 중요.</li>
<li>함수 몸체 내에서 변수처럼 취급. 식별자 네이밍 규칙 적용.</li>
</ul>
<h4 id="함수-몸체"><a href="#함수-몸체" class="headerlink" title="+ 함수 몸체"></a>+ 함수 몸체</h4><ul>
<li>함수 호출에 의해 한 번에 실행되는 문들을 모아둔 코드블록.</li>
</ul>
</li>
</ul>
<h2 id="4-함수-정의"><a href="#4-함수-정의" class="headerlink" title="4. 함수 정의"></a>4. 함수 정의</h2><ul>
<li><p>함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수(ES6)</p>
<h4 id="4-1-함수-선언문"><a href="#4-1-함수-선언문" class="headerlink" title="4-1. 함수 선언문"></a>4-1. 함수 선언문</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 참조 : console.dir 은 함수객체의 프로퍼티까지 출력. node.js 에서는 console.log와 차이없음.</span><br><span class="line"></span><br><span class="line">console.dir(add);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 호출</span><br><span class="line"></span><br><span class="line">console.log(add(2, 5));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>함수 선언문과 함수 리터럴은 형태가 동일하나 함수 리터럴은 함수 이름을 생략할 수 있다.</p>
</li>
<li><p>함수 선언문은 표현식이 아닌 문이기 때문에 변수에 할당할 수 없으나, 변수에 할당을 해도 동작을 한다. 그 이유는 함수 리터럴 표현식으로 자바스크립트 엔진이 해석하는 경우가 있기 때문.<br>단독으로 사용하면 함수 선언문으로 해석하고, 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석해버림.</p>
</li>
<li><p>함수 선언문과 리터럴의 내부동작 차이.<br>함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당.<br>(수업시간에 확실히 이해한 후 내용 보충)</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.</p>
<h4 id="4-2-함수-표현식"><a href="#4-2-함수-표현식" class="headerlink" title="4-2. 함수 표현식"></a>4-2. 함수 표현식</h4></li>
<li><p>값의 성질을 갖는 객체 &gt; 일급 객체</p>
</li>
<li><p>함수도 일급 객체.</p>
</li>
<li><p>함수 표현식 = 함수 리터럴 = 값처럼 함수 객체를 변수에 할당할 수 있다.</p>
</li>
<li><p>함수 이름 생략 가능 &gt; 익명 함수 (생략하는 것이 일반적)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 표현식</span><br><span class="line">var add &#x3D; function (x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(add(2,5)); &#x2F;&#x2F; 7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 기명 함수 표현식</span><br><span class="line">var add &#x3D; function foo (x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 객체를 가리키는 식별자로 호출</span><br><span class="line">console.log(add(2, 5));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 이름으로 호출하면 ReferenceError</span><br><span class="line">console.log(foo(2, 5));</span><br></pre></td></tr></table></figure></li>
<li><p>함수 선언문 &gt; 표현식이 아닌 문</p>
</li>
<li><p>함수 표현식 &gt; 표현식인 문</p>
</li>
<li><p>유사하지만 동일하게 동작하지 않는다.</p>
<h4 id="4-3-함수-생성-시점과-함수-호이스팅"><a href="#4-3-함수-생성-시점과-함수-호이스팅" class="headerlink" title="4-3. 함수 생성 시점과 함수 호이스팅"></a>4-3. 함수 생성 시점과 함수 호이스팅</h4></li>
<li><p>함수 호이스팅 :<br>함수 선언문 &gt; 선언문이기 때문에 runtime 이전에 먼저 실행. (함수 객체가 먼저 생성되고, 식별자에 할당까지 완료)<br>그래서 함수 선언문 이전에 참조, 호출 가능</p>
</li>
</ul>
<ul>
<li><p>함수 호이스팅과 변수 호이스팅의 차이점 :<br>변수 호이스팅은 선언만 runtime 이전에 실행되므로 undefined로 초기화되어 변수 선언문 이전에 참조하면 undefined로 평가됨.<br>함수 호이스팅은 함수 객체로 초기화되므로 선언문 이전에 호출해도 호출이 가능함.</p>
</li>
<li><p>함수 선언문 &gt; 함수 호이스팅</p>
</li>
<li><p>함수 표현식 &gt; 변수 호이스팅 :<br>변수 할당문의 값이 함수 리터럴인 문이므로 런타임에 평가되어 함수객체가 됨. 함수 표현식 이전에 함수를 참조하면 변수와 같이 undefined로 평가됨. 호출하면 TypeError 발생.</p>
<h4 id="4-4-Function-생성자-함수"><a href="#4-4-Function-생성자-함수" class="headerlink" title="4-4. Function 생성자 함수"></a>4-4. Function 생성자 함수</h4></li>
</ul>
<ul>
<li><p>빌트인 함수</p>
</li>
<li><p>매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환.</p>
</li>
<li><p>new 연산자 없이 호출해도 된다.</p>
</li>
<li><p>생성자 함수 : 객체를 생성하는 함수</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x + y&#39;);</span><br><span class="line"></span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>
<ul>
<li>Function 생성자 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작하므로 권장하지 않음.</li>
</ul>
<h4 id="4-5-화살표-함수-ES6"><a href="#4-5-화살표-함수-ES6" class="headerlink" title="4-5. 화살표 함수 (ES6)"></a>4-5. 화살표 함수 (ES6)</h4><ul>
<li>function 키워드 대신 =&gt; 를 사용.</li>
<li>익명함수<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 화살표 함수</span><br><span class="line">const add &#x3D; (x, y) &#x3D;&gt; &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 더 간결하게 쓰는 법</span><br><span class="line">const add &#x3D; (x, y) &#x3D;&gt; x + y;</span><br><span class="line"></span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure></li>
<li>완전 대체는 불가능. 생성자 함수로 사용할 수 없고, this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.</li>
</ul>
</li>
</ul>
<h2 id="5-함수-호출"><a href="#5-함수-호출" class="headerlink" title="5. 함수 호출"></a>5. 함수 호출</h2><ul>
<li><p>함수 호출 연산자로 호출</p>
</li>
<li><p>식별자(인수1, 인수2, 인수3…)</p>
</li>
<li><p>인수1 &gt; 매개변수1 할당 / 인수2 &gt; 매개변수2 할당</p>
</li>
<li><p>현재 실행 흐름 중단 &gt; 함수로 컨트롤 이동 &gt; 매개변수에 인수가 순서대로 할당 &gt; 함수 몸체의 문 실행</p>
<h4 id="5-1-매개변수와-인수"><a href="#5-1-매개변수와-인수" class="headerlink" title="5-1. 매개변수와 인수"></a>5-1. 매개변수와 인수</h4><ul>
<li><p>인수는 값으로 평가될 수 있는 표현식이어야 함. 개수와 타입에 제한 없음.</p>
</li>
<li><p>매개변수는 함수 몸채 내부에서 변수와 동일하게 취급.</p>
</li>
<li><p>함수 몸체 내에서 일반 변수와 마찬가지로 undefined로 초기화 된 후 인수가 순서대로 할당 됨. 호출될 때마다 같은 단계를 거침.</p>
</li>
<li><p>매개변수는 함수 몸체 내에서만 참조가능.</p>
</li>
<li><p>매개변수와 인수의 개수가 맞지 않는 경우에 에러가 발생하지는 않고, 인수가 부족한 매개변수의 값은 undefined. 인수가 초과될 경우에는 초과된 인수는 무시되고, 암묵적으로 arguments 객체의 프로퍼티로 보관됨.</p>
<h4 id="5-2-인수-확인"><a href="#5-2-인수-확인" class="headerlink" title="5-2. 인수 확인"></a>5-2. 인수 확인</h4></li>
<li><p>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않고, 매개변수의 타입을 사전에 지정할 수도 없다.</p>
</li>
<li><p>적절한 인수가 전달되었는지 확인이 필요. (수업시간에 확실히 이해한 후 내용 보충)</p>
<h4 id="5-3-매개변수의-최대-개수"><a href="#5-3-매개변수의-최대-개수" class="headerlink" title="5-3. 매개변수의 최대 개수"></a>5-3. 매개변수의 최대 개수</h4></li>
<li><p>ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않지만, 수가 너무 많아지면 함수의 사용방법도 어려워지고 유지 보수성도 나빠진다.</p>
</li>
<li><p>이상적인 함수는 한가지 일만 해야하며 가급적 작게 만들어야 한다. 따라서 매개변수의 개수도 적을 수록 좋다.</p>
</li>
<li><p>최대 3개 이상을 넘지 않는 것을 권장.</p>
</li>
<li><p>그 이상 필요하다면 하나의 매개변수를 선언하고 객체를 인수로 전달받는 것이 유리하다.</p>
</li>
<li><p>객체를 인수로 사용하면, 프로퍼티 키만 지정하면 매개변수의 순서를 신경쓰지 않아도 되고, 값의 의미를 설명하는 프로퍼티키를 사용하게 되므로 가독성도 좋아지고 실수도 줄어듦.</p>
</li>
<li><p>하지만 함수 내부에서 전달받은 객체를 변경하면 함수 외부의 객체도 변경되는 부수효과가 발생되므로 주의.</p>
<h4 id="5-4-반환문"><a href="#5-4-반환문" class="headerlink" title="5-4. 반환문"></a>5-4. 반환문</h4></li>
<li><p>return 키워드, 반환값으로 이루어진 반환문을 사용하여 실행 결과를 함수 외부로 반환할 수 있다.</p>
</li>
<li><p>함수 호출 표현식은 return 키워드가 반환한 값, 반환값으로 평가됨.</p>
</li>
<li><p>반환문의 역할 : </p>
<ul>
<li>함수의 실행을 중단하고 함수 몸체를 빠져나간다. 다음의 문은 실행되지않고 무시된다.</li>
<li>return 키워드 뒤에 지정한 값을 반환한다. 값을 지정하지 않으면 undefined가 반환된다.</li>
</ul>
</li>
<li><p>반환문을 생략하면 함수 몸체의 마지막 문까지 실행한 후 undefined를 반환</p>
</li>
<li><p>return 키워드와 반환값 사이에 줄바꿈이 있으면 세미콜론이 자동삽입되어 의도와 다른 결과가 발생할 수 있다.</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-참조에-의한-전달과-외부-상태의-변경"><a href="#6-참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="6. 참조에 의한 전달과 외부 상태의 변경"></a>6. 참조에 의한 전달과 외부 상태의 변경</h2><ul>
<li>매개변수는 타입에 따라 값에 의한 전달, 참조에 의한 전달방식을 따른다.</li>
<li>불변 객체를 사용하여 문제 해결.</li>
<li>순수 함수<br>(수업시간에 확실히 이해한 후 내용 보충)</li>
</ul>
<h1 id="7-다양한-함수의-형태"><a href="#7-다양한-함수의-형태" class="headerlink" title="7. 다양한 함수의 형태"></a>7. 다양한 함수의 형태</h1><h4 id="7-1-즉시-실행-함수"><a href="#7-1-즉시-실행-함수" class="headerlink" title="7-1. 즉시 실행 함수"></a>7-1. 즉시 실행 함수</h4><ul>
<li><p>함수 정의와 동시에 즉시 호출되는 함수</p>
</li>
<li><p>(…) 그룹 연산자로 감싸야 함.</p>
</li>
<li><p>단 한번만 호출되며 다시 호출할 수는 없다. 익명함수 사용.</p>
</li>
<li><p>기명함수도 사용할 수 있지만, 함수 이름으로 다시 호출할 수 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 익명 즉시 실행 함수</span><br><span class="line">(function () &#123;</span><br><span class="line">  var a &#x3D; 3;</span><br><span class="line">  var b &#x3D; 5;</span><br><span class="line">  return a * b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></li>
<li><p>그룹연산자로 묶어 함수를 먼저 평가하여 함수 객체를 생성함.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.</span><br><span class="line">var res &#x3D; (function () &#123;</span><br><span class="line">  var a &#x3D; 3;</span><br><span class="line">  var b &#x3D; 5;</span><br><span class="line">  return a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(res); &#x2F;&#x2F; 15</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 일반 함수처럼 인수를 전달 할 수 있다.</span><br><span class="line">res &#x3D; (function (a, b) &#123;</span><br><span class="line">  return a * b;</span><br><span class="line">&#125;(3, 5));</span><br><span class="line"></span><br><span class="line">console.log(res); &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>

<h4 id="7-2-재귀-함수"><a href="#7-2-재귀-함수" class="headerlink" title="7-2. 재귀 함수"></a>7-2. 재귀 함수</h4></li>
<li><p>함수가 자기 자신을 호출하는 것</p>
</li>
<li><p>자기 자신을 호출하는 행위, 재귀 호출을 수행하는 함수.</p>
</li>
<li><p>반복 연산을 간단하게 구현가능.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n) &#123;</span><br><span class="line">  if (n &lt;&#x3D; 1) return 1;</span><br><span class="line">  &#x2F;&#x2F; 재귀 호출</span><br><span class="line">  return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(factorial(0));</span><br><span class="line">console.log(factorial(1));</span><br><span class="line">console.log(factorial(2));</span><br><span class="line">console.log(factorial(3));</span><br><span class="line">console.log(factorial(4));</span><br><span class="line">console.log(factorial(5));</span><br></pre></td></tr></table></figure></li>
<li><p>무한 재귀 호출하므로, 멈출 수 있는 탈출 조건을 반드시 만들어야 함.<br>(stack overflow 에러)<br>(한 번 더 공부할 것)</p>
<h4 id="7-3-중첩-함수"><a href="#7-3-중첩-함수" class="headerlink" title="7-3. 중첩 함수"></a>7-3. 중첩 함수</h4></li>
<li><p>함수 내부에 정의된 함수 &gt; 중첩함수, 내부함수</p>
</li>
<li><p>중첩함수를 포함하는 함수 &gt; 외부함수</p>
</li>
<li><p>중첩함수를 외부함수를 돕는 헬퍼함수</p>
</li>
<li><p>문이 위치할 수 있는 문맥이라면 어디든지 함수 정의 가능.</p>
</li>
<li><p>if문이나 for문 코드블록 내에서 정의할 수 있으나, 호이스팅으로 인해 혼란이 발생할 수 있으므로 바람직하지않다.</p>
<h4 id="7-4-콜백-함수"><a href="#7-4-콜백-함수" class="headerlink" title="7-4. 콜백 함수"></a>7-4. 콜백 함수</h4></li>
<li><p>매개변수를 통해 전달되는 함수</p>
</li>
<li><p>고차 함수: 콜백함수를 매개변수를 통해 전달받은 함수</p>
<h4 id="7-5-순수-함수와-비순수-함수"><a href="#7-5-순수-함수와-비순수-함수" class="headerlink" title="7-5. 순수 함수와 비순수 함수"></a>7-5. 순수 함수와 비순수 함수</h4></li>
<li><p>순수 함수: 부수 효과가 없는 함수</p>
</li>
<li><p>비순수 함수: 부수 효과가 있는 함수</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/02/review-operator-control-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/review-operator-control-flow/" class="post-title-link" itemprop="url">review - 'js/operator & control flow'</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-02-26 10:56:56 / Modified: 11:12:38" itemprop="dateCreated datePublished" datetime="2020-02-26T10:56:56+09:00">2020-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/review/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="자바스크립트-복습-연산자의-부수효과-for문-if문과-삼항연산자"><a href="#자바스크립트-복습-연산자의-부수효과-for문-if문과-삼항연산자" class="headerlink" title="자바스크립트 복습 - 연산자의 부수효과, for문, if문과 삼항연산자"></a>자바스크립트 복습 - 연산자의 부수효과, for문, if문과 삼항연산자</h1><h3 id="1-연산자-–의-부수효과"><a href="#1-연산자-–의-부수효과" class="headerlink" title="1. 연산자 ++, –의 부수효과"></a>1. 연산자 ++, –의 부수효과</h3><p>다른 산술 연산자들은</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 10;</span><br><span class="line">var b &#x3D; 20;</span><br><span class="line"></span><br><span class="line">console.log(10 + 20); &#x2F;&#x2F; 30</span><br><span class="line"></span><br><span class="line">console.log(a); &#x2F;&#x2F; 10</span><br><span class="line">console.log(b); &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>
<p>처럼 변수의 값이 바뀌지는 않는다.</p>
<p>하지만 ++, – 증가 감소 단항 산술 연산자는</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 10;</span><br><span class="line"></span><br><span class="line">console.log(++a); </span><br><span class="line">console.log(a); &#x2F;&#x2F; 11</span><br></pre></td></tr></table></figure>
<p>처럼 변수의 값 자체가 증감에 따라 바뀌어 버린다.</p>
<p>이것을 부수효과가 있다고 한다.</p>
<p>+일 땐 원시값이 변경 불가능한 값이기 때문에 변하지 않는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; true;</span><br><span class="line">var b &#x3D; false;</span><br><span class="line"></span><br><span class="line">var c &#x3D; +a;</span><br><span class="line">console.log(c); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">var d &#x3D; +b;</span><br><span class="line">console.log(d); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">console.log(a); &#x2F;&#x2F; true</span><br><span class="line">console.log(b); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>다른 학생이 러버덕 발표한 내용으로 예제 코딩해봤는데<br>이 쪽이 이해가 더 쉬운 것 같다.</p>
<h3 id="2-for문의-실행순서"><a href="#2-for문의-실행순서" class="headerlink" title="2. for문의 실행순서"></a>2. for문의 실행순서</h3><p>for 문은 조건에 따라 참인지 거짓인지 평가해 거짓이 나올 때 까지 코드 블록을 반복한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (변수 선언문 or 할당문, 조건문, 증감식) &#123;</span><br><span class="line">실행할 코드블록</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>변수 선언문 or 할당문 &gt; 조건문 : 참인지 거짓인지 평가, 참이라면 &gt; 코드블록 실행 &gt; 나와서 증감식 &gt;<br>다시 조건문 : 참인지 거짓인지 평가해서 거짓일 때까지 반복실행.</p>
<h3 id="3-if문과-삼항연산자"><a href="#3-if문과-삼항연산자" class="headerlink" title="3. if문과 삼항연산자"></a>3. if문과 삼항연산자</h3><p>if문 : </p>
<p>조건에 따라 실행할 코드블록을 결정하는 경우에 사용</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (조건문1) &#123; 조건문 1이 참이면 실행 &#125;</span><br><span class="line">else if (조건문2) &#123; 조건문2가 참이면 실행 &#125;</span><br><span class="line">else &#123; 둘 다 거짓이면 실행 &#125;</span><br></pre></td></tr></table></figure>

<p>삼항조건연산자 :</p>
<p>조건에 따라 참 거짓으로 실행 값을 결정한다</p>
<p>if 문은 삼항조건연산자로 바꿀 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">조건문 ? 참 : 거짓</span><br><span class="line"></span><br><span class="line">조건문2 ? ( 조건문1 ? 참: 거짓 ) : 조건문2 거짓;</span><br><span class="line">조건문2 ? 조건문2 참 : (조건문1 ? 참: 거짓);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mare nubium</p>
  <div class="site-description" itemprop="description">Front-end web development를 공부합니다.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mare nubium</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
