<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"songseungeun.github.io","root":"/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Front-end web development를 공부합니다.">
<meta property="og:type" content="website">
<meta property="og:title" content="mare nubium">
<meta property="og:url" content="https://songseungeun.github.io/index.html">
<meta property="og:site_name" content="mare nubium">
<meta property="og:description" content="Front-end web development를 공부합니다.">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="mare nubium">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://songseungeun.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>mare nubium</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mare nubium</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">구름의 바다 front-end web development</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-array/" class="post-title-link" itemprop="url">javascript-array</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-24 13:46:17 / Modified: 17:44:39" itemprop="dateCreated datePublished" datetime="2020-03-24T13:46:17+09:00">2020-03-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="배열"><a href="#배열" class="headerlink" title="배열"></a>배열</h1><h2 id="배열-생성"><a href="#배열-생성" class="headerlink" title="배열 생성"></a>배열 생성</h2><h3 id="1-Array-of"><a href="#1-Array-of" class="headerlink" title="1. Array.of"></a>1. Array.of</h3><ul>
<li>전달된 인수를 요소로 갖는 새 Array 인스턴스를 생성.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Array.of(7); &#x2F;&#x2F; [7]</span><br><span class="line">Array.of(1, 2, 3); &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line"></span><br><span class="line">Array(7); &#x2F;&#x2F; [ , , , , , , ]</span><br><span class="line">Array(1, 2, 3); &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h3 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2. Array.from"></a>2. Array.from</h3><ul>
<li>유사 배열 객체 또는 이터러블 객체를 변환하여 새로운 배열을 생성.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array.from</span><br><span class="line">&#x2F;&#x2F; 유사배열객체나 반복가능한객체(이터러블)을 얕게 복사해 새로운 배열객체를 만든다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.from (arrayLike, mapFn, thisArg)</span><br><span class="line">&#x2F;&#x2F; Array.from (유사배열객체나 이터러블, 배열의 모든 요소에 대해 호출할 맵핑 함수, mapFn실행시에 this로 사용할 값)</span><br><span class="line">&#x2F;&#x2F; 새로운 Array 인스턴스를 반환한다. </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.from(obj).map(mapFn, thisArg) 와 같다. (ex-array-map.js 참고)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; string에서 배열 만들기</span><br><span class="line">const stringArr &#x3D; Array.from(&#39;foo&#39;);</span><br><span class="line">console.log(stringArr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Map에서 배열 만들기</span><br><span class="line">const m &#x3D; new Map([[1, 2], [2, 4], [4, 8]]);</span><br><span class="line">console.log(m);</span><br><span class="line"></span><br><span class="line">const n &#x3D; Array.from(m);</span><br><span class="line">console.log(n);</span><br><span class="line"></span><br><span class="line">let myMap &#x3D; new Map([</span><br><span class="line">  [1, &#39;one&#39;],</span><br><span class="line">  [2, &#39;two&#39;],</span><br><span class="line">  [3, &#39;three&#39;],</span><br><span class="line">]);</span><br><span class="line">console.log(myMap);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 배열 형태를 가진 객체에서 배열 만들기</span><br><span class="line">function f() &#123;</span><br><span class="line">  return Array.from(arguments);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(f(1, 2, 3));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 시퀀스 생성기 range</span><br><span class="line"></span><br><span class="line">const range &#x3D; (start, stop, step) &#x3D;&gt; </span><br><span class="line">Array.from(&#123; length: (stop - start) &#x2F; step + 1&#125;, (_, i) &#x3D;&gt; start + (i * step));</span><br><span class="line"></span><br><span class="line">console.log(range(0, 10, 1));</span><br><span class="line">console.log(range(1, 10, 2));</span><br></pre></td></tr></table></figure>

<h2 id="배열-메소드"><a href="#배열-메소드" class="headerlink" title="배열 메소드"></a>배열 메소드</h2><h3 id="1-Array-isArray"><a href="#1-Array-isArray" class="headerlink" title="1. Array.isArray"></a>1. Array.isArray</h3><ul>
<li>Array 생성자 함수의 정적 메소드.</li>
<li>주어진 인수가 배열이면 true, 아니면 false</li>
</ul>
<h3 id="2-Array-prototype-indexOf"><a href="#2-Array-prototype-indexOf" class="headerlink" title="2. Array.prototype.indexOf"></a>2. Array.prototype.indexOf</h3><ul>
<li>원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환.</li>
<li>해당하는 요소가 없을 경우 -1 반환.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array.prototype.indexOf</span><br><span class="line">&#x2F;&#x2F; 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환</span><br><span class="line"></span><br><span class="line">const arrIndexOf &#x3D; [1, 2, 2, 3];</span><br><span class="line"></span><br><span class="line">console.log(arrIndexOf.indexOf(2)); &#x2F;&#x2F; 1</span><br><span class="line">console.log(arrIndexOf.indexOf(4)); &#x2F;&#x2F; -1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 두번째 인수는 검색을 시작할 인덱스</span><br><span class="line">console.log(arrIndexOf.indexOf(2, 2)); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 배열에 요소가 존재하는지 확인</span><br><span class="line">const foods &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하는지 확인</span><br><span class="line">if (foods.indexOf(&#39;orange&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">  &#x2F;&#x2F; foods 배열에 &#39;orange&#39; 요소가 존재하지 않으면 추가</span><br><span class="line">  foods.push(&#39;orange&#39;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(foods); &#x2F;&#x2F; [ &#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39; ]</span><br></pre></td></tr></table></figure>

<ul>
<li>그냥 한번 함수로 만들어 봄</li>
<li>파인애플이 있는지 확인하고 없으면 추가해서 리턴<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const foods &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;orange&#39;];</span><br><span class="line">const foods2 &#x3D; [&#39;pizza&#39;, &#39;cola&#39;, &#39;fineapple&#39;];</span><br><span class="line"></span><br><span class="line">function fruitsAdd(fruits) &#123;</span><br><span class="line">  if (fruits.indexOf(&#39;fineapple&#39;) &#x3D;&#x3D;&#x3D; -1) &#123;</span><br><span class="line">    fruits.push(&#39;fineapple&#39;);</span><br><span class="line">    return console.log(fruits);</span><br><span class="line">  &#125;</span><br><span class="line">  return console.log(&#96;fineapple이 있는 배열 [ $&#123;fruits&#125; ]&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fruitsAdd(foods);</span><br><span class="line">fruitsAdd(foods2);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; indexOf 메소드 대신 ES7 Array.prototype.includes 메소드를 사용하면</span><br><span class="line">&#x2F;&#x2F; 가독성이 좋다</span><br><span class="line"></span><br><span class="line">const foods3 &#x3D; [&#39;milk&#39;, &#39;coffee&#39;];</span><br><span class="line"></span><br><span class="line">if (!foods3.includes(&#39;orange&#39;)) &#123;</span><br><span class="line">  foods3.push(&#39;orange&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foods3);</span><br></pre></td></tr></table></figure>

<h3 id="3-Array-prototype-push-mutator-method-원본-배열을-직접-변경"><a href="#3-Array-prototype-push-mutator-method-원본-배열을-직접-변경" class="headerlink" title="3. Array.prototype.push (mutator method : 원본 배열을 직접 변경)"></a>3. Array.prototype.push (mutator method : 원본 배열을 직접 변경)</h3><ul>
<li>인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 값을 반환한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.push &gt; mutator method</span><br><span class="line">&#x2F;&#x2F; 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고</span><br><span class="line">&#x2F;&#x2F; 변경된 length 값을 반환한다. </span><br><span class="line"></span><br><span class="line">const arrPush &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">let result &#x3D; arrPush.push(3, 4);</span><br><span class="line">console.log(result); &#x2F;&#x2F; 4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; push 메소드는 원본 배열을 직접 변경한다.</span><br><span class="line">console.log(arrPush); &#x2F;&#x2F; [ 1, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">arrPush[arrPush.length] &#x3D; 5;</span><br><span class="line">console.log(arrPush); &#x2F;&#x2F; [ 1, 2, 3, 4, 5 ]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 스프레드 문법</span><br><span class="line">const newArr &#x3D; [ ... arrPush, 6];</span><br><span class="line"></span><br><span class="line">console.log(newArr); &#x2F;&#x2F; [ 1, 2, 3, 4, 5, 6 ]</span><br></pre></td></tr></table></figure>
<h3 id="4-Array-prototype-pop-mutator-method-원본-배열을-직접-변경"><a href="#4-Array-prototype-pop-mutator-method-원본-배열을-직접-변경" class="headerlink" title="4. Array.prototype.pop (mutator method : 원본 배열을 직접 변경)"></a>4. Array.prototype.pop (mutator method : 원본 배열을 직접 변경)</h3></li>
<li>원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array.prototype.pop &gt; mutator method</span><br><span class="line">&#x2F;&#x2F; pop 메소드는 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다.</span><br><span class="line">&#x2F;&#x2F; 원본 배열이 빈 배열이면 undefined를 반환.</span><br><span class="line"></span><br><span class="line">const arrPop &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">let result2 &#x3D; arrPop.pop();</span><br><span class="line">console.log(result2); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">console.log(arrPop); &#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure>
<h3 id="5-Array-prototype-unshift-mutator-method-원본-배열을-직접-변경"><a href="#5-Array-prototype-unshift-mutator-method-원본-배열을-직접-변경" class="headerlink" title="5. Array.prototype.unshift (mutator method : 원본 배열을 직접 변경)"></a>5. Array.prototype.unshift (mutator method : 원본 배열을 직접 변경)</h3></li>
<li>인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length값을 반환.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array.prototype.unshift &gt; mutator method</span><br><span class="line">&#x2F;&#x2F; 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고</span><br><span class="line">&#x2F;&#x2F; 변경된 length 값을 반환한다.</span><br><span class="line"></span><br><span class="line">const arrUnshift &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">let result3 &#x3D; arrUnshift.unshift(3, 4);</span><br><span class="line">console.log(result3); &#x2F;&#x2F; 4</span><br><span class="line"></span><br><span class="line">console.log(arrUnshift); &#x2F;&#x2F; [ 3, 4, 1, 2 ]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 스프레드 문법</span><br><span class="line">const newArr2 &#x3D; [5, ...arrUnshift];</span><br><span class="line"></span><br><span class="line">console.log(newArr2); &#x2F;&#x2F; [ 5, 3, 4, 1, 2 ]</span><br></pre></td></tr></table></figure>
<h3 id="6-Array-prototype-shift-mutator-method-원본-배열을-직접-변경"><a href="#6-Array-prototype-shift-mutator-method-원본-배열을-직접-변경" class="headerlink" title="6. Array.prototype.shift (mutator method : 원본 배열을 직접 변경)"></a>6. Array.prototype.shift (mutator method : 원본 배열을 직접 변경)</h3></li>
<li>첫번째 요소를 제거하고 제거한 요소를 반환.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array.prototype.shift &gt; mutator method</span><br><span class="line"></span><br><span class="line">const arrShift &#x3D; [1, 2];</span><br><span class="line"></span><br><span class="line">let result4 &#x3D; arrShift.shift();</span><br><span class="line">console.log(result4); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">console.log(arrShift); &#x2F;&#x2F; [2]</span><br></pre></td></tr></table></figure>
<h3 id="7-Array-prototype-concat-accessor-method-새로운-배열을-생성하여-반환"><a href="#7-Array-prototype-concat-accessor-method-새로운-배열을-생성하여-반환" class="headerlink" title="7. Array.prototype.concat (accessor method : 새로운 배열을 생성하여 반환)"></a>7. Array.prototype.concat (accessor method : 새로운 배열을 생성하여 반환)</h3></li>
<li>인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환. 배열을 해체하여 새로운 배열의 요소로 추가.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array.prototype.concat &gt; accessor method</span><br><span class="line">&#x2F;&#x2F; 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환.</span><br><span class="line">&#x2F;&#x2F; 인수로 전달한 값이 배열인 경우, 배열을 해체하여 새로운 배열의 요소로 추가한다.</span><br><span class="line"></span><br><span class="line">const arrConcat1 &#x3D; [1, 2];</span><br><span class="line">const arrConcat2 &#x3D; [3, 4];</span><br><span class="line"></span><br><span class="line">let result5 &#x3D; arrConcat1.concat(arrConcat2);</span><br><span class="line">console.log(result5); &#x2F;&#x2F; [ 1, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">result5 &#x3D; arrConcat1.concat(5);</span><br><span class="line">console.log(result5); &#x2F;&#x2F; [1, 2, 5]</span><br><span class="line">console.log(arrConcat1); &#x2F;&#x2F; [ 1, 2 ]</span><br><span class="line"></span><br><span class="line">result5 &#x3D; arrConcat1.concat(arrConcat2, 5);</span><br><span class="line">console.log(result5); &#x2F;&#x2F; 12 + 34 + 5</span><br><span class="line"></span><br><span class="line">console.log(arrConcat1); &#x2F;&#x2F; [ 1, 2 ]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; push 와 unshift 메소드는 concat 메소드로 대체가능.</span><br><span class="line">&#x2F;&#x2F; push unshift &gt; 원본배열 직접변경 concat &gt; 새로운 배열 반환</span><br><span class="line">&#x2F;&#x2F; push unshift 원본 배열을 변수에 할당할 것</span><br><span class="line">&#x2F;&#x2F; concat 반환값을 반드시 변수에 할당받을 것</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; concat 메소드는 인수로 전달받은 배열을 해체하여 새로운 배열의 마지막 요소로 추가한다.</span><br><span class="line">let result6 &#x3D; [1, 2].concat(arrConcat2);</span><br><span class="line">console.log(result6); &#x2F;&#x2F; [ 1, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">result6 &#x3D; result6.concat(5, 6);</span><br><span class="line">console.log(result6); &#x2F;&#x2F; [ 1, 2, 3, 4, 5, 6 ]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 스프레드 문법</span><br><span class="line">let result7 &#x3D; [...[1, 2], ...[3, 4]];</span><br><span class="line">console.log(result7);</span><br></pre></td></tr></table></figure>
<h3 id="8-Array-prototype-splice-mutator-method-원본-배열을-직접-변경"><a href="#8-Array-prototype-splice-mutator-method-원본-배열을-직접-변경" class="headerlink" title="8. Array.prototype.splice (mutator method : 원본 배열을 직접 변경)"></a>8. Array.prototype.splice (mutator method : 원본 배열을 직접 변경)</h3></li>
<li>중간에 요소를 추가하거나, 중간에 있는 요소를 제거.</li>
<li>3개의 매개변수가 있다.<ul>
<li>start : 제거하기 시작할 인덱스. start만을 지정하면 원본배열의 start부터 모든 요소를 제거.</li>
<li>deleteCount : start 부터 제거할 요소의 개수. (옵션)</li>
<li>items : 제거한 위치에 삽입될 요소들의 목록. (옵션)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; Array.prototype.splice</span><br><span class="line">&#x2F;&#x2F; .splice(start, deleteCount, items)</span><br><span class="line">&#x2F;&#x2F; mutator method</span><br><span class="line">const arrSplice &#x3D; [1, 2, 3, 4];</span><br><span class="line">const result8 &#x3D; arrSplice.splice(1, 2, 20, 30); &#x2F;&#x2F; 예상 index1인 2부터 2개인 2, 3이 지워지고 20, 30이 들어간다</span><br><span class="line"></span><br><span class="line">console.log(result8); &#x2F;&#x2F; 제거한 요소가 반환 2, 3</span><br><span class="line">console.log(arrSplice); &#x2F;&#x2F; 예상했던 결과인 1, 20, 30, 4가 나옴</span><br><span class="line"></span><br><span class="line">const result9 &#x3D; arrSplice.splice(1); &#x2F;&#x2F; 제거할 요소를 생략하면 첫번째 인수로 전달된 시작인덱스부터 모든 요소 제거</span><br><span class="line"></span><br><span class="line">console.log(arrSplice); &#x2F;&#x2F; [1] 남은 요소 원본 배열 반환</span><br><span class="line">console.log(result9); [20, 30, 4]</span><br></pre></td></tr></table></figure>
<h3 id="9-Array-prototype-slice-accessor-method-새로운-배열을-생성하여-반환"><a href="#9-Array-prototype-slice-accessor-method-새로운-배열을-생성하여-반환" class="headerlink" title="9. Array.prototype.slice (accessor method : 새로운 배열을 생성하여 반환)"></a>9. Array.prototype.slice (accessor method : 새로운 배열을 생성하여 반환)</h3></li>
</ul>
</li>
<li>인수로 전달된 범위의 요소들을 복사하여 반환.</li>
<li>2개의 매개변수.<ul>
<li>start : 복사를 시작할 인덱스. 음수의 경우 -2 는 배열의 마지막 2개의 요소를 반환한다.</li>
<li>end : 복사를 종료할 인덱스. (옵션) 기본값은 length값.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let result &#x3D; arr.slice(0, 1);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">result &#x3D; arr.slice(1, 2);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">result &#x3D; arr.slice(1);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">result &#x3D; arr.slice(-2);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
<h3 id="10-Array-prototype-join-mutator-method-원본-배열을-직접-변경"><a href="#10-Array-prototype-join-mutator-method-원본-배열을-직접-변경" class="headerlink" title="10. Array.prototype.join (mutator method : 원본 배열을 직접 변경)"></a>10. Array.prototype.join (mutator method : 원본 배열을 직접 변경)</h3></li>
</ul>
</li>
<li>모든 요소를 문자열로 변환한 후, 인수로 전달받은 값에 구분자로 연결한 문자열을 반환한다. 생략가능하며 기본은 , 이다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3, 4];</span><br><span class="line"></span><br><span class="line">let result &#x3D; arr.join();</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">result &#x3D; arr.join(&#39;&#39;);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">result &#x3D; arr.join(&#39;:&#39;);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
<h3 id="11-Array-prototype-reverse-mutator-method-원본-배열을-직접-변경"><a href="#11-Array-prototype-reverse-mutator-method-원본-배열을-직접-변경" class="headerlink" title="11. Array.prototype.reverse (mutator method : 원본 배열을 직접 변경)"></a>11. Array.prototype.reverse (mutator method : 원본 배열을 직접 변경)</h3></li>
<li>요소 순서를 반대로 변경한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line">const result &#x3D; arr.reverse();</span><br><span class="line"></span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>
<h3 id="12-Array-prototype-fill-mutator-method-원본-배열을-직접-변경"><a href="#12-Array-prototype-fill-mutator-method-원본-배열을-직접-변경" class="headerlink" title="12. Array.prototype.fill (mutator method : 원본 배열을 직접 변경)"></a>12. Array.prototype.fill (mutator method : 원본 배열을 직접 변경)</h3></li>
<li>인수로 전달받은 값을 요소로 배열의 처음부터 끝까지 채운다.</li>
<li>두번째 인수로 채우기 시작할 인덱스를 전달.</li>
<li>세번째 인수로 요소 채우기를 멈출 인덱스를 전달.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">arr.fill(0);</span><br><span class="line"></span><br><span class="line">console.log(arr);</span><br><span class="line"></span><br><span class="line">const arr2 &#x3D; [2, 3, 4];</span><br><span class="line"></span><br><span class="line">arr2.fill(0, 1);</span><br><span class="line"></span><br><span class="line">console.log(arr2);</span><br><span class="line"></span><br><span class="line">const arr3 &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">arr3.fill(0, 1, 3);</span><br><span class="line"></span><br><span class="line">console.log(arr3);</span><br><span class="line"></span><br><span class="line">const arr20 &#x3D; new Array(20);</span><br><span class="line">console.log(arr20);</span><br><span class="line"></span><br><span class="line">const result &#x3D; arr20.fill(7);</span><br><span class="line"></span><br><span class="line">console.log(arr20);</span><br></pre></td></tr></table></figure></li>
<li>fill 메소드로 요소를 채울 경우, 모든 요소를 하나의 값만으로 채울 수 밖에 없다는 단점이 있다. Array.from 정적메소드를 사용하여 두번째 인수로 전달한 함수를 통해 값을 만들면서 요소를 채울 수 있다. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function generateSequences(length &#x3D; 0) &#123;</span><br><span class="line">  return Array.from(new Array(length), (_, i) &#x3D;&gt; i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(generateSequences(3));</span><br></pre></td></tr></table></figure>
<h3 id="13-Array-prototype-includes"><a href="#13-Array-prototype-includes" class="headerlink" title="13. Array.prototype.includes"></a>13. Array.prototype.includes</h3></li>
<li>배열 내에 특정 요소가 포함되어 있는지 확인하여 true, false 반환</li>
<li>첫번째 인수로 검색할 대상을 지정한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">let result &#x3D; arr.includes(2);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">result &#x3D; arr.includes(100);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">result &#x3D; arr.includes(1, 1);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">result &#x3D; arr.includes(3, -1);</span><br><span class="line">console.log(result);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; indexOF 메소드를 사용해도 확인 가능하나,</span><br><span class="line">&#x2F;&#x2F; -1을 비교해야하고, NaN이 포함되어있는지 확인할 수 없다.</span><br><span class="line"></span><br><span class="line">console.log([NaN].indexOf(NaN) !&#x3D;&#x3D; -1);</span><br><span class="line">console.log([NaN].includes(NaN));</span><br></pre></td></tr></table></figure>
<h3 id="14-Array-prototype-flat"><a href="#14-Array-prototype-flat" class="headerlink" title="14. Array.prototype.flat"></a>14. Array.prototype.flat</h3></li>
<li>인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.</li>
<li>인수로 중첩 배열을 평탄화 할 깊이를 전달할 수 있다. 생략할 경우 기본값은 1이다. Infinity를 전달하면 중첩 배열 모두를 평탄화한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log([1, [2, 3, 4, 5]].flat());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1단계 평탄화</span><br><span class="line">console.log([1, [2, [3, [4]]]].flat(1));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2단계 평탄화</span><br><span class="line">console.log([1, [2, [3, [4]]]].flat(2));</span><br><span class="line">console.log([1, [2, [3, [4]]]].flat().flat());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 끝까지 평탄화</span><br><span class="line">console.log([1, [2, [3, [4]]]].flat(Infinity));</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="배열-고차-함수"><a href="#배열-고차-함수" class="headerlink" title="배열 고차 함수"></a>배열 고차 함수</h2><ul>
<li>Higher-Order Function, HOF</li>
</ul>
<h3 id="1-Array-prototype-sort-mutator-method-원본-배열을-직접-변경"><a href="#1-Array-prototype-sort-mutator-method-원본-배열을-직접-변경" class="headerlink" title="1. Array.prototype.sort (mutator method : 원본 배열을 직접 변경)"></a>1. Array.prototype.sort (mutator method : 원본 배열을 직접 변경)</h3><ul>
<li>배열의 요소를 정렬.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">const fruits &#x3D; [&#39;Banana&#39;, &#39;Orange&#39;, &#39;Apple&#39;];</span><br><span class="line"></span><br><span class="line">fruits.sort();</span><br><span class="line"></span><br><span class="line">console.log(fruits);</span><br><span class="line"></span><br><span class="line">const fruitsKr &#x3D; [&#39;바나나&#39;, &#39;오렌지&#39;, &#39;사과&#39;];</span><br><span class="line"></span><br><span class="line">fruitsKr.sort();</span><br><span class="line"></span><br><span class="line">console.log(fruitsKr);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 순서를 뒤집고 싶으면 (내림차순) reverse 메소드 사용</span><br><span class="line"></span><br><span class="line">fruits.reverse();</span><br><span class="line"></span><br><span class="line">console.log(fruits);</span><br><span class="line"></span><br><span class="line">let alphabet &#x3D; Array.from(&#39;gwpfjeyzhvacbmd&#39;);</span><br><span class="line"></span><br><span class="line">alphabet.sort().reverse();</span><br><span class="line"></span><br><span class="line">console.log(alphabet);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체를 요소로 갖는 배열을 정렬하는 예제</span><br><span class="line"></span><br><span class="line">const todos &#x3D; [</span><br><span class="line">  &#123; id: 4, content: &#39;JavaScript&#39;&#125;,</span><br><span class="line">  &#123; id: 1, content: &#39;HTML&#39;&#125;,</span><br><span class="line">  &#123; id: 2, content: &#39;CSS&#39;&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function compare(key) &#123;</span><br><span class="line">  return (a, b) &#x3D;&gt; (a[key] &gt; b[key] ? 1 : (a[key] &lt; b[key] ? -1 : 0));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">todos.sort(compare(&#39;id&#39;));</span><br><span class="line">console.log(todos);</span><br><span class="line"></span><br><span class="line">todos.sort(compare(&#39;content&#39;));</span><br><span class="line">console.log(todos);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-Array-prototype-forEach"><a href="#2-Array-prototype-forEach" class="headerlink" title="2. Array.prototype.forEach"></a>2. Array.prototype.forEach</h3><ul>
<li>배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1, 2, 3];</span><br><span class="line">let pows &#x3D; [];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; for 문 사용</span><br><span class="line">for (let i &#x3D; 0; i &lt; numbers.length; i++) &#123;</span><br><span class="line">  pows.push(numbers[i] ** 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(pows);</span><br><span class="line"></span><br><span class="line">pows &#x3D; [];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; forEach 메소드 사용</span><br><span class="line">numbers.forEach(item &#x3D;&gt; pows.push(item ** 2));</span><br><span class="line"></span><br><span class="line">console.log(pows);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 요소값, 인덱스, this</span><br><span class="line"></span><br><span class="line">[1, 2, 3].forEach((item, index, arr) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;요소값: $&#123;item&#125;, 인덱스: $&#123;index&#125;, this: $&#123;arr&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line"></span><br><span class="line">array1.forEach(element &#x3D;&gt; console.log(element));</span><br><span class="line"></span><br><span class="line">const items &#x3D; [&#39;item1&#39;, &#39;item2&#39;, &#39;item3&#39;];</span><br><span class="line">const copy &#x3D; [];</span><br><span class="line"></span><br><span class="line">items.forEach(item &#x3D;&gt; copy.push(item + &#96;0&#96;));</span><br><span class="line"></span><br><span class="line">console.log(copy);</span><br></pre></td></tr></table></figure>
<h3 id="3-Array-prototype-map"><a href="#3-Array-prototype-map" class="headerlink" title="3. Array.prototype.map"></a>3. Array.prototype.map</h3></li>
<li>배열을 순회하며 배열의 각 요소에 대하여 인수로 전달된 콜백 함수를 실행한다.</li>
<li>콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Array.prototype.map()</span><br><span class="line"></span><br><span class="line">const arr1 &#x3D; [1, 4, 9, 16];</span><br><span class="line"></span><br><span class="line">const map1 &#x3D; arr1.map(x &#x3D;&gt; x * 2);</span><br><span class="line"></span><br><span class="line">console.log(map1);</span><br><span class="line"></span><br><span class="line">const map2 &#x3D; arr1.map(function (x) &#123;</span><br><span class="line">  return x + 2;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(map2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; arr.map(callback(currentValue[, index[, array]])[, thisArg])</span><br><span class="line">&#x2F;&#x2F; arr.map (새로운 배열 요소를 생성하는 함수</span><br><span class="line">&#x2F;&#x2F; (3가지 인수&gt; 처리할 현재 요소, 처리할 현재 요소의 인덱스, map()을 호출한 배열), </span><br><span class="line">&#x2F;&#x2F; callback을 실행할 때 this로 사용되는 값)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 반환 값 &gt; 배열의 각 요소에 대해 실행한 callback의 결과를 모은 새로운 배열</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; map은 callback 함수의 각각에 요소에 대해 한번씩 순서대로 부른다.</span><br><span class="line">&#x2F;&#x2F; undefined도 포함해서 배열값이 들어있는 인덱스만 호출한다.</span><br><span class="line">&#x2F;&#x2F; 값이 삭제되거나 할당&#x2F;정의되지 않은 인덱스에 대해서는 호출하지 않는다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; callback은 호출될 때 대상 요소의 값, 인덱스, 원본배열 3가지 인수를 전달 받는다.</span><br><span class="line">&#x2F;&#x2F; thisArg 가 전달된 경우 callback 함수의 this 값으로 사용된다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; map은 호출한 배열의 값을 변형하지 않는다. 단, callback 함수에 의해 변형될 수 있다.</span><br><span class="line">&#x2F;&#x2F; map이 처리할 요소의 범위는 첫 callback을 호출하기 전에 정해지고,</span><br><span class="line">&#x2F;&#x2F; 시작한 이후 추가된 요소들은 callback을 호출하지 않는다.</span><br><span class="line">&#x2F;&#x2F; 배열에 존재하는 요소들의 값이 바뀐경우, map이 방문하는 시점의 값이 callback에 전달된다.</span><br><span class="line"></span><br><span class="line">let numbers &#x3D; [1, 4, 9];</span><br><span class="line">let roots &#x3D; numbers.map(Math.sqrt); &#x2F;&#x2F; 제곱근</span><br><span class="line">&#x2F;&#x2F; numbers.map(item &#x3D;&gt; Math.sqrt(item));</span><br><span class="line"></span><br><span class="line">console.log(roots);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; map을 활용해 배열 속 객체를 재구성하기</span><br><span class="line"></span><br><span class="line">let kvArray &#x3D; [&#123;key: 1, value: 10&#125;,</span><br><span class="line">              &#123;key: 2, value: 20&#125;,</span><br><span class="line">              &#123;key: 3, value: 30&#125;];</span><br><span class="line"></span><br><span class="line">let reformattedArray &#x3D; kvArray.map(function(obj)&#123;</span><br><span class="line">  let rObj &#x3D; &#123;&#125;;</span><br><span class="line">  rObj[obj.key] &#x3D; obj.value;</span><br><span class="line">  return rObj;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(reformattedArray);</span><br><span class="line">console.log(kvArray);</span><br><span class="line"></span><br><span class="line">let kbArray2 &#x3D; [&#123;key: 1, value: 100&#125;,</span><br><span class="line">                &#123;key: 2, value: 200&#125;,</span><br><span class="line">                &#123;key: 3, value: 300&#125;];</span><br><span class="line"></span><br><span class="line">let newArray &#x3D; kbArray2.map(function(obj) &#123;</span><br><span class="line">  console.log(obj.key);</span><br><span class="line">  console.log(obj.value);</span><br><span class="line">  let rObj2 &#x3D; &#123;&#125;;</span><br><span class="line">  rObj2[obj.key] &#x3D; obj.value;</span><br><span class="line">  return rObj2</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(newArray);</span><br><span class="line"></span><br><span class="line">let newArray2 &#x3D; kbArray2.map(obj &#x3D;&gt; &#123;</span><br><span class="line">  let rObj &#x3D; &#123;&#125;;</span><br><span class="line">  rObj[obj.key] &#x3D; obj.value;</span><br><span class="line">  return rObj</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(newArray2);</span><br><span class="line"></span><br><span class="line">let numbers2 &#x3D; [1, 4, 9];</span><br><span class="line">let doubles &#x3D; numbers.map(function(num)&#123;</span><br><span class="line">  return num * 2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(doubles);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ASCII 인코딩 값을 요소로 갖는 배열</span><br><span class="line">let map &#x3D; Array.prototype.map;</span><br><span class="line">let a &#x3D; map.call(&#39;Hello World&#39;, function(x) &#123;return x.charCodeAt(0);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>
<h3 id="4-Array-prototype-filter"><a href="#4-Array-prototype-filter" class="headerlink" title="4. Array.prototype.filter"></a>4. Array.prototype.filter</h3><ul>
<li>배열을 순회하며 true인 배열 요소의 값만을 추출한 새로운 배열을 반환한다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">const odds &#x3D; numbers.filter(item &#x3D;&gt; item % 2);</span><br><span class="line"></span><br><span class="line">console.log(odds);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 배열의 특정요소 제거하기</span><br><span class="line"></span><br><span class="line">const users &#x3D; [</span><br><span class="line">  &#123; id: 1, name: &#39;Lee&#39; &#125;,</span><br><span class="line">  &#123; id: 2, name: &#39;Kim&#39; &#125;,</span><br><span class="line">  &#123; id: 3, name: &#39;Kim&#39; &#125;,</span><br><span class="line">  &#123; id: 4, name: &#39;Kim&#39; &#125;,</span><br><span class="line">  &#123; id: 5, name: &#39;Kim&#39; &#125;,</span><br><span class="line">  &#123; id: 6, name: &#39;Kim&#39; &#125;,</span><br><span class="line">  &#123; id: 7, name: &#39;Kim&#39; &#125;,</span><br><span class="line">  &#123; id: 8, name: &#39;Kim&#39; &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">const userList &#x3D; users.filter(</span><br><span class="line">  function (item) &#123;</span><br><span class="line">    console.log(item);</span><br><span class="line">    console.log(item.id);</span><br><span class="line">    return item.id % 2;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">console.log(userList);</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/post-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/post-1/" class="post-title-link" itemprop="url">post</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-24 13:46:06" itemprop="dateCreated datePublished" datetime="2020-03-24T13:46:06+09:00">2020-03-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-closure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-closure/" class="post-title-link" itemprop="url">javascript-closure</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-18 13:21:06 / Modified: 13:21:35" itemprop="dateCreated datePublished" datetime="2020-03-18T13:21:06+09:00">2020-03-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-this/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-this/" class="post-title-link" itemprop="url">javascript-this</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-15 20:06:16" itemprop="dateCreated datePublished" datetime="2020-03-15T20:06:16+09:00">2020-03-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-16 18:05:42" itemprop="dateModified" datetime="2020-03-16T18:05:42+09:00">2020-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><h2 id="1-this-키워드"><a href="#1-this-키워드" class="headerlink" title="1. this 키워드"></a>1. this 키워드</h2><ul>
<li>메소드는 자신이 속한 객체의 프로퍼티를 참조하고 변경하려면 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 한다.</li>
<li>객체 리터럴 방식으로 생성한 객체의 경우, 메소드 내부에서 메소드 자신이 속한 객체를 가리키는 식별자를 재귀적으로 참조할 수 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const circle &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 프로퍼티: 객체 고유의 상태 데이터</span><br><span class="line">  radius: 5,</span><br><span class="line">  &#x2F;&#x2F; 메소드: 상태 데이터를 참조하고 조작하는 동작</span><br><span class="line">  getDiameter() &#123;</span><br><span class="line">    &#x2F;&#x2F; 이 메소드가 자신이 속한 객체의 프로퍼티나 다른 메소드를 참조하려면</span><br><span class="line">    &#x2F;&#x2F; 자신이 속한 객체 circle 참조할 수 있어야 한다.</span><br><span class="line">    return 2 * circle.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(circle.getDiameter()); &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>

<ul>
<li><p>객체 리터럴은 할당 단계에 평가되고, 메소드가 호출되는 시점에 객체리터럴의 평가가 완료되어 객체가 생성되어 할당된 이후이다. 따라서 메소드 내부에서 식별자를 참조할 수 있다.</p>
</li>
<li><p>하지만 자기 자신이 속한 객체를 재귀적으로 참조하는 방식은 일반적이지 않으며 바람직하지도 않다.</p>
</li>
<li><p>생성자 함수 내부에서 자신이 생성할 인스턴스를 참조할 수 있어야 한다. 하지만 생성자 함수를 정의하는 시점에는 아직 인스턴스를 생성하기 이전이므로 식별자를 알 수 없다.</p>
</li>
<li><p>따라서 자신이 생성할 인스턴스를 가리키는 특수한 식별자가 필요하다. &gt; this</p>
</li>
<li><p>this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(Self-referencing variable)이다. </p>
</li>
<li><p>함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 지역변수처럼 사용할 수 있다. 단, this가 가리키는 값, 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.</p>
</li>
<li><p>this는 어디서든지 참조 가능하다.</p>
</li>
<li><p>전역에서 this는 전역 객체 window를 가리킨다.</p>
</li>
<li><p>일반 함수 내부에서 this는 전역 객체 window를 가리킨다.</p>
</li>
<li><p>메소드 내부에서 this는 메소드를 호출한 객체를 가리킨다.</p>
</li>
<li><p>생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</p>
</li>
<li><p>strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩 된다. 일반 함수 내부에서 this를 사용할 필요가 없기 때문이다.</p>
</li>
</ul>
<h2 id="2-함수-호출-방식과-this-바인딩"><a href="#2-함수-호출-방식과-this-바인딩" class="headerlink" title="2. 함수 호출 방식과 this 바인딩"></a>2. 함수 호출 방식과 this 바인딩</h2><ul>
<li>this가 가리키는 값. 즉 this 바인딩은 함수의 호출 방식, 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.</li>
</ul>
<blockquote>
<p>렉시컬 스코프와 this 바인딩은 결정시기가 다르다.<br>함수의 상위 스코프를 결정하는 방식인 렉시컬 스코프는 함수 정의가 평가되어<br>함수 객체가 생성되는 시점에 상위 스코프를 결정한다.<br>this에 바인딩 될 객체는 함수 호출 시점에 결정된다.</p>
</blockquote>
<ul>
<li><p>bind 내의 this와 this.value의 this가 다르다.</p>
</li>
<li><p>함수 몸체 내부 외부 차이</p>
</li>
<li><p>slice 메소드가 프로토타입 내부의 메소드라 함수내부에 this가 있다</p>
</li>
<li><p>arguments 가 this로 slice를 쓴다 &gt; 간접호출</p>
</li>
<li><p>유사배열객체 &gt; 배열 로 바꾸는 방법 Array.prototype.slice.apply(arguments);</p>
</li>
<li><p>ES6 […arguments] …&lt;- 디스트럭처링 비구조화</p>
</li>
<li><p>apply, call</p>
</li>
<li><p>함수를 호출하는 것이 주 목적 .앞의 함수를 호출</p>
</li>
<li><p>그 때 .앞의 this를 교체해준다. </p>
</li>
<li><p>bind</p>
</li>
<li><p>호출 X. this만 교체한다.</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-built-in-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-built-in-object/" class="post-title-link" itemprop="url">javascript-built-in-object</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-15 16:48:43 / Modified: 20:04:32" itemprop="dateCreated datePublished" datetime="2020-03-15T16:48:43+09:00">2020-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="빌트인-객체"><a href="#빌트인-객체" class="headerlink" title="빌트인 객체"></a>빌트인 객체</h1><h2 id="1-자바스크립트-객체의-분류"><a href="#1-자바스크립트-객체의-분류" class="headerlink" title="1. 자바스크립트 객체의 분류"></a>1. 자바스크립트 객체의 분류</h2><h3 id="표준-빌트인-객체"><a href="#표준-빌트인-객체" class="headerlink" title="+ 표준 빌트인 객체"></a>+ 표준 빌트인 객체</h3><ul>
<li>ECMAScript 사양에 정의된 객체.</li>
<li>애플리케이션 전역의 공통 기능을 제공.</li>
<li>전역 객체의 프로퍼티로서 제공되므로, 별도의 선언 없이 언제나 참조할 수 있다.</li>
</ul>
<h3 id="호스트-객체"><a href="#호스트-객체" class="headerlink" title="+ 호스트 객체"></a>+ 호스트 객체</h3><ul>
<li>ECMAScript 사양에 정의되어 있지 않지만, 자바스크립트 실행 환경에서 추가적으로 제공하는 객체.</li>
<li>브라우저 환경 &gt; 클라이언트 사이드 Web API</li>
<li>Node.js &gt; Node.js 고유의 API</li>
</ul>
<h3 id="사용자-정의-객체"><a href="#사용자-정의-객체" class="headerlink" title="+ 사용자 정의 객체"></a>+ 사용자 정의 객체</h3><ul>
<li>기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체.</li>
</ul>
<h2 id="2-표준-빌트인-객체"><a href="#2-표준-빌트인-객체" class="headerlink" title="2. 표준 빌트인 객체"></a>2. 표준 빌트인 객체</h2><h3 id="생성자-함수-객체인-표준-빌트인-객체"><a href="#생성자-함수-객체인-표준-빌트인-객체" class="headerlink" title="+ 생성자 함수 객체인 표준 빌트인 객체"></a>+ 생성자 함수 객체인 표준 빌트인 객체</h3><ul>
<li>프로토타입 메소드, 정적 메소드 제공</li>
<li>생성한 인스턴스의 프로토타입 : 표준 빌트인 객체의 prototype 프로퍼티에 바인딩 된 객체 (ex/ String &gt; String.prototype)</li>
<li>인스턴스 없이도 호출 가능한 정적 메소드 제공</li>
</ul>
<h3 id="생성자-함수-객체가-아닌-표준-빌트인-객체"><a href="#생성자-함수-객체가-아닌-표준-빌트인-객체" class="headerlink" title="+ 생성자 함수 객체가 아닌 표준 빌트인 객체"></a>+ 생성자 함수 객체가 아닌 표준 빌트인 객체</h3><ul>
<li>정적 메소드만 제공</li>
</ul>
<h2 id="3-원시값과-래퍼-객체"><a href="#3-원시값과-래퍼-객체" class="headerlink" title="3. 원시값과 래퍼 객체"></a>3. 원시값과 래퍼 객체</h2><ul>
<li><p>래퍼 객체 (wrapper object) : 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체</p>
</li>
<li><p>원시값인 문자열, 숫자, 불리언 값의 경우 객체처럼 마침표 표기법이나 대괄호 표기법으로 접근하면 자바스크립트 엔진이 일시적으로 연관된 객체로 변환해주기 때문이다. </p>
</li>
<li><p>원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하고, 생성된 객체로 프로퍼티에 접근하거나 메소드를 호출하고 다시 원시값으로 되돌린다.</p>
</li>
<li><p>String 생성자 함수의 인스턴스는 String.prototype 의 메소드를 상속받아 사용할 수 있다.</p>
</li>
<li><p>래퍼 객체의 처리가 종료하면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 되돌리고 래퍼객체는 가비지 컬렉션의 대상이 된다.</p>
</li>
<li><p>불리언 값도 마찬가지이지만 불리언 값으로 메소드를 호출할 일은 없으므로 유용하지 않다.</p>
</li>
<li><p>Symbol도 래퍼객체를 생성하지만 Symbol함수로 생성하므로 다른 원시값과는 차이가 있다.</p>
</li>
<li><p>문자열, 숫자, 불리언, 심볼은 암묵적으로 생성되는 래퍼객체에 의해 마치 객체처럼 사용할 수 있으며 표준 빌트인 객체인 String, Number, Boolean, Symbol의 프로토타입 메소드 또는 프로퍼티를 참조할 수 있다.</p>
</li>
<li><p>따라서 String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출하여 문자열 숫자 불리언 인스턴스를 생성할 필요가 없으며 권장하지 않는다.</p>
</li>
</ul>
<h2 id="4-전역-객체"><a href="#4-전역-객체" class="headerlink" title="4. 전역 객체"></a>4. 전역 객체</h2><ul>
<li>코드가 실행되기 이전에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다.</li>
<li>브라우저 환경 &gt; window (or self, this, frames)</li>
<li>Node.js &gt; global (globalThis)</li>
<li>표준 빌트인 객체들과 환경에 따른 호스트 객체(클라이언트 web API or Node.js 의 호스트 API) 그리고 var 키워드로 선언한 전역변수와 전역함수를 프로퍼티로 갖는다.</li>
<li>전역객체는 계층적 구조상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체이다. </li>
</ul>
<h3 id="전역-객체의-특징"><a href="#전역-객체의-특징" class="headerlink" title="* 전역 객체의 특징"></a>* 전역 객체의 특징</h3><ol>
<li>개발자가 의도적으로 생성할 수 없다. 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.</li>
<li>전역 객체의 프로퍼티를 참조할 때 window, global 을 생략할 수 있다.</li>
<li>모든 표준 빌트인 객체를 프로퍼티로 가지고 있다.<br>( Object, String, Number, Boolean, Function, Array, RegExp, Date, Math, Promise 등 )</li>
<li>자바스크립트 실행 환경(브라우저 환경 또는 Node.js 환경)에 따라 추가적으로 프로퍼티와 메소드를 갖는다.</li>
<li>var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역 그리고 전역 함수는 전역 객체의 프로퍼티가 된다.</li>
<li>let 이나 const 키워드로 선언한 전역 변수는 전역객체의 프로퍼티가 아니다. 보이지 않는 개념적인 블록내에 존재하게 된다.</li>
<li>브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다. 여러 개의 script 태그를 통해 자바스크립트 코드를 분리하여도 하나의 전역 객체 window를 공유한다.</li>
</ol>
<ul>
<li>전역 객체의 프로퍼티와 메소드는 전역 객체를 가리키는 식별자, window 나 global을 생략하여 참조/호출 할 수 있으므로 전역 변수와 전역 함수처럼 사용할 수 있다.</li>
</ul>
<h3 id="4-1-빌트인-전역-프로퍼티"><a href="#4-1-빌트인-전역-프로퍼티" class="headerlink" title="4-1. 빌트인 전역 프로퍼티"></a>4-1. 빌트인 전역 프로퍼티</h3><ul>
<li>전역 객체의 프로퍼티를 의미. 애플리케이션 전역에서 사용하는 값을 제공.</li>
</ul>
<h4 id="4-1-1-Infinity"><a href="#4-1-1-Infinity" class="headerlink" title="4-1-1. Infinity"></a>4-1-1. Infinity</h4><ul>
<li>양/음의 무한대를 나타내는 숫자값 infinity를 갖는다.</li>
</ul>
<h4 id="4-1-2-NaN"><a href="#4-1-2-NaN" class="headerlink" title="4-1-2. NaN"></a>4-1-2. NaN</h4><ul>
<li>Not-a-Number 를 나타내는 숫자값 NaN을 갖는다. Number.NaN 프로퍼티와 같다.</li>
</ul>
<h4 id="4-1-3-undefined"><a href="#4-1-3-undefined" class="headerlink" title="4-1-3. undefined"></a>4-1-3. undefined</h4><ul>
<li>원시타입 undefined를 값으로 갖는다.</li>
</ul>
<h3 id="4-2-빌트인-전역-함수"><a href="#4-2-빌트인-전역-함수" class="headerlink" title="4-2. 빌트인 전역 함수"></a>4-2. 빌트인 전역 함수</h3><ul>
<li>애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메소드이다.</li>
</ul>
<h4 id="4-2-1-eval"><a href="#4-2-1-eval" class="headerlink" title="4-2-1. eval"></a>4-2-1. eval</h4><ul>
<li><p>문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행하여 결과값을 반환한다.</p>
</li>
<li><p>여러 개의 문으로 이루어져 있다면 모든 문을 실행 후 마지막 결과값을 반환한다.</p>
</li>
<li><p>eval 함수는 런타임에 자신이 호출된 기존의 스코프를 동적으로 수정한다.<br>( eval 함수에 전달된 코드를 이미 그 위치에 존재하던 코드처럼 호출된 함수의 스코프에서 실행된다. )</p>
</li>
<li><p>자바스크립트는 렉시컬 스코프를 따르므로 함수 정의가 평가되는 시점에 스코프가 결정된다 &gt; 스코프는 런타임에 결정되는 것이 아니다.</p>
</li>
<li><p>eval 함수는 렉시컬 스코프를 동적으로 수정할 수 있다. 하지만 성능적인 면에서 손해를 감수해야 한다.</p>
</li>
<li><p>strict mode 에서 eval 함수는 기존의 스코프를 수정하지 않고 자신만의 독자적인 스코프를 생성한다.</p>
</li>
<li><p>eval 함수에 전달한 변수 선언문이 let, const 키워드를 사용했다면 엄격모드가 적용된다.</p>
</li>
<li><p>eval 함수를 통해 사용자로부터 입력받은 콘텐츠를 실행하는 것은 보안에 취약하다. 또 최적화가 수행되지 않으므로 처리속도가 느리다. 가급적 금지되어야 한다.</p>
</li>
</ul>
<h4 id="4-2-2-inFinite"><a href="#4-2-2-inFinite" class="headerlink" title="4-2-2. inFinite"></a>4-2-2. inFinite</h4><ul>
<li>매개 변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환한다.</li>
<li>전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다.</li>
<li>inFinite(null) 은 true를 반환한다. null 을 숫자타입으로 변환하면 0이 되기 때문이다.</li>
</ul>
<h4 id="4-2-3-isNaN"><a href="#4-2-3-isNaN" class="headerlink" title="4-2-3. isNaN"></a>4-2-3. isNaN</h4><ul>
<li>매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리언 타입으로 반환한다.</li>
<li>숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다.</li>
</ul>
<h4 id="4-2-4-parseFloat"><a href="#4-2-4-parseFloat" class="headerlink" title="4-2-4. parseFloat"></a>4-2-4. parseFloat</h4><ul>
<li>매개변수에 전달된 문자열을 부동소수점 숫자(floating point number)로 변환하여 반환한다.</li>
</ul>
<h4 id="4-2-5-parseInt"><a href="#4-2-5-parseInt" class="headerlink" title="4-2-5. parseInt"></a>4-2-5. parseInt</h4><ul>
<li><p>매개변수에 전달된 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다. 반환값은 언제나 10진수이다.</p>
</li>
<li><p>문자열이 아니면 문자열로 변환한 후 정수형 숫자로 해석하여 반환한다.</p>
</li>
<li><p>2번째 매개변수에는 진법을 나타내는 기수(2 ~ 36)를 지정할 수 있다. 기수를 지정하면 첫번째 매개변수에 전달된 문자열을 해당 기수의 숫자로 해석하여 반환한다.</p>
</li>
<li><p>반환값은 언제나 10진수고, 기수를 생략하면 10진수로 해석하여 반환한다.</p>
</li>
<li><p>첫번째 매개변수에 전달된 문자열이 0x 또는 0X로 시작하는 16진수 리터럴이라면 16진수로 해석하여 10진수 정수로 반환한다.</p>
</li>
<li><p>하지만 2진수 리터럴과 8진수 리터럴은 제대로 해석하지 못한다.</p>
</li>
<li><p>첫번째 매개변수에 전달된 문자열의 첫번째 문자가 해당 지수의 숫자로 변환될 수 없다면 NaN을 반환한다.</p>
</li>
<li><p>두번째 문자부터 해당 진수를 나타내는 숫자가 아닌 문자와 마주치면 이 문자와 계속되는 문자들은 전부 무시되며 해석된 정수값만을 반환한다.</p>
</li>
<li><p>공백이 있다면 첫번째 문자열만 해석하여 반환하며 전후 공백은 무시된다.</p>
</li>
<li><p>기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 Number.prototype.toString 메소드를 사용한다.</p>
</li>
</ul>
<h4 id="4-2-6-encodeURI-decodeURI"><a href="#4-2-6-encodeURI-decodeURI" class="headerlink" title="4-2-6. encodeURI / decodeURI"></a>4-2-6. encodeURI / decodeURI</h4><ul>
<li>매개변수로 전달된 URI(Uniform Resource Identifer) 를 인코딩한다.</li>
<li>URI는 인터넷에 있는 자원을 나타내는 유일한 주소를 말한다.</li>
<li>URI의 하위개념으로 URL, URN이 있다.</li>
</ul>
<blockquote>
<p><a href="http://www.mydomain.com:80/javascript/global.php?who=me&amp;type=human#Intro" target="_blank" rel="noopener">http://www.mydomain.com:80/javascript/global.php?who=me&amp;type=human#Intro</a></p>
<p>http:// ~ #Intro : URI<br>http:// ~ .php : URL<br>www. ~ #Intro : URN</p>
</blockquote>
<ul>
<li>인코딩이란 URI 의 문자들을 이스케이프 처리하는 것을 의미한다.</li>
<li>이스케이프 처리는 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋 (ASCII Character-set)으로 변환하는 것이다.</li>
</ul>
<h4 id="4-2-7-encodeURIComponent-decodeURIComponent"><a href="#4-2-7-encodeURIComponent-decodeURIComponent" class="headerlink" title="4-2-7. encodeURIComponent / decodeURIComponent"></a>4-2-7. encodeURIComponent / decodeURIComponent</h4><ul>
<li><p>encodeURIComponent 함수는 매개변수로 전달된 URI 구성요소를 인코딩한다.</p>
</li>
<li><p>decodeURIComponent 함수는 매개변수로 전달된 URI 구성요소를 디코딩한다.</p>
</li>
<li><p>encodeURIComponent 함수는 매개변수로 전달된 문자열을 URI의 구성요소인 쿼리 파라미터의 일부로 간주한다. 따라서 쿼리 파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩한다.</p>
</li>
<li><p>encodeURI 함수는 매개변수로 전달된 문자열을 완전한 URI 전체로 간주한다. 따라서 쿼리파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩하지 않는다.</p>
</li>
</ul>
<h3 id="4-3-암묵적-전역-implicit-global"><a href="#4-3-암묵적-전역-implicit-global" class="headerlink" title="4-3. 암묵적 전역 (implicit global)"></a>4-3. 암묵적 전역 (implicit global)</h3><ul>
<li>함수내에 선언하지 않은 식별자가 마치 선언된 전역번수 처럼 동작한다.</li>
<li>이는 선언하지 않은 식별자에 값을 할당하면 전역객체의 프로퍼티가 되기 때문이다.</li>
<li>변수가 아니라 window 의 전역객체의 프로퍼티로 추가된 것이므로 변수 호이스팅이 발생하지 않는다.</li>
<li>단지 프로퍼티이므로 delete 연산자로 삭제할 수 있다. 전역 변수는 프로퍼티이지만 delete 연산자로 삭제할 수 없다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-strict-mode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-strict-mode/" class="post-title-link" itemprop="url">javascript-strict-mode</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-15 15:50:51 / Modified: 16:45:48" itemprop="dateCreated datePublished" datetime="2020-03-15T15:50:51+09:00">2020-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="엄격-모드"><a href="#엄격-모드" class="headerlink" title="엄격 모드"></a>엄격 모드</h1><h2 id="1-strict-mode란"><a href="#1-strict-mode란" class="headerlink" title="1. strict mode란?"></a>1. strict mode란?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  x &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure>
<p><strong>&lt; 암묵적 전역 &gt;</strong></p>
<ol>
<li>foo 함수의 스코프에서 변수 x의 선언을 검색 &gt; 없음</li>
<li>foo 함수 컨텍스트의 상위 스코프 (전역 스코프) 에서 변수 x의 선언을 검색 &gt; 없음</li>
<li>ReferenceError를 throw 할 것 같지만, 암묵적으로 전역 객체에 프로퍼티 x를 동적 생성. &gt; 전역 변수처럼 사용할 수 있다.</li>
</ol>
<ul>
<li>암묵적 전역은 오류를 발생시키는 원인이 된다.</li>
<li>잠재적인 오류를 발생시키기 어려운 개발환경을 만들기 위해 strict mode 가 추가되었다. (ES5)</li>
<li>strict mode : 자바스크립트 언어의 문법을 보다 엄격히 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킨다.</li>
<li>ESLint 같은 린트도구도 유사한 효과를 얻을 수 있다. &gt; 소스 코드를 실행하기 전에 스캔하여 문법적 오류뿐만 아니라 잠재적 오류까지 찾아내고 이유를 리포팅해주는 도구.</li>
</ul>
<h2 id="2-strict-mode의-적용"><a href="#2-strict-mode의-적용" class="headerlink" title="2. strict mode의 적용"></a>2. strict mode의 적용</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">  x &#x3D; 10; &#x2F;&#x2F; ReferenceError: x is not defined</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure>
<ul>
<li>전역의 선두 또는 함수 몸체의 선두에 ‘use strict’; 를 추가한다.</li>
<li>코드 선두에 위치시키지 않으면 제대로 동작하지 않는다.</li>
</ul>
<h2 id="3-전역에-strict-mode를-적용하는-것은-피하자"><a href="#3-전역에-strict-mode를-적용하는-것은-피하자" class="headerlink" title="3. 전역에 strict mode를 적용하는 것은 피하자."></a>3. 전역에 strict mode를 적용하는 것은 피하자.</h2><ul>
<li>즉시 실행 함수로 스크립트 전체를 감싸서 스코프를 구분하고 즉시 실행 함수의 선두에 strict mode를 적용한다.</li>
</ul>
<h2 id="4-함수-단위로-strict-mode를-적용하는-것도-피하자"><a href="#4-함수-단위로-strict-mode를-적용하는-것도-피하자" class="headerlink" title="4. 함수 단위로 strict mode를 적용하는 것도 피하자."></a>4. 함수 단위로 strict mode를 적용하는 것도 피하자.</h2><ul>
<li>non-strict mode 와 strict mode를 혼용하는 것도 바람직 하지 않고, strict mode가 적용된 함수가 참조할 함수 외부의 컨텍스트에 strict mode를 적용하지 않는다면 문제가 발생할 수 있다.</li>
<li>strict mode는 즉시 실행 함수로 감싼 스크립트 단위로 적용하는 것이 바람직하다.</li>
</ul>
<h2 id="5-strict-mode가-발생시키는-에러"><a href="#5-strict-mode가-발생시키는-에러" class="headerlink" title="5. strict mode가 발생시키는 에러"></a>5. strict mode가 발생시키는 에러</h2><h3 id="5-1-암묵적-전역"><a href="#5-1-암묵적-전역" class="headerlink" title="5-1. 암묵적 전역"></a>5-1. 암묵적 전역</h3><ul>
<li>선언하지 않은 변수를 참조하면 ReferenceError가 발생한다.</li>
</ul>
<h3 id="5-2-변수-함수-매개변수의-삭제"><a href="#5-2-변수-함수-매개변수의-삭제" class="headerlink" title="5-2. 변수, 함수, 매개변수의 삭제"></a>5-2. 변수, 함수, 매개변수의 삭제</h3><ul>
<li>delete 연산자로 변수, 함수, 매개변수를 삭제하면 SyntaxError가 발생한다.</li>
</ul>
<h3 id="5-3-매개변수-이름의-중복"><a href="#5-3-매개변수-이름의-중복" class="headerlink" title="5-3. 매개변수 이름의 중복"></a>5-3. 매개변수 이름의 중복</h3><ul>
<li>중복된 함수 매개변수 이름을 사용하면 SyntaxError가 발생한다.</li>
</ul>
<h3 id="5-4-with-문의-사용"><a href="#5-4-with-문의-사용" class="headerlink" title="5-4. with 문의 사용"></a>5-4. with 문의 사용</h3><ul>
<li>with 문을 사용하면 SyntaxError가 발생한다.</li>
</ul>
<h2 id="6-strict-mode-적용에-의한-변화"><a href="#6-strict-mode-적용에-의한-변화" class="headerlink" title="6. strict mode 적용에 의한 변화"></a>6. strict mode 적용에 의한 변화</h2><h3 id="6-1-일반-함수의-this"><a href="#6-1-일반-함수의-this" class="headerlink" title="6-1. 일반 함수의 this"></a>6-1. 일반 함수의 this</h3><ul>
<li>strict mode 에서 일반함수로서 호출하면 this에 undefined가 바인딩된다. 생성자 함수가 아닌 일반 함수 내부에서 this를 사용할 필요가 없기 때문이다.</li>
</ul>
<h3 id="6-2-arguments-객체"><a href="#6-2-arguments-객체" class="headerlink" title="6-2. arguments 객체"></a>6-2. arguments 객체</h3><ul>
<li>strict mode 에서는 매개변수에 전달된 인수를 재할당하여 변경해도 arguments 객체에 반영되지 않는다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/review-constructor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/review-constructor/" class="post-title-link" itemprop="url">review-constructor</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-10 13:30:27 / Modified: 17:51:24" itemprop="dateCreated datePublished" datetime="2020-03-10T13:30:27+09:00">2020-03-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/review/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="자바스크립트-복습-생성자-함수에-의한-객체-생성"><a href="#자바스크립트-복습-생성자-함수에-의한-객체-생성" class="headerlink" title="자바스크립트 복습 - 생성자 함수에 의한 객체 생성"></a>자바스크립트 복습 - 생성자 함수에 의한 객체 생성</h1><h2 id="1-Object-생성자-함수"><a href="#1-Object-생성자-함수" class="headerlink" title="1. Object 생성자 함수"></a>1. Object 생성자 함수</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; new Object();</span><br></pre></td></tr></table></figure>

<ul>
<li>new 연산자 + Object 생성자 함수 &gt; 빈 객체 생성</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.name &#x3D; &#39;Lee&#39;;</span><br><span class="line">person.sayHello &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;Hi! My name is &#39; + this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>빈 객체에 프로퍼티 또는 메소드를 추가하여 객체 완성.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;, sayHello: f&#125;</span><br><span class="line">person.sayHello(); &#x2F;&#x2F; Hi! My name is Lee</span><br></pre></td></tr></table></figure>

<ul>
<li><p>인스턴스 (instance) : 생성자 함수에 의해 생성된 객체.</p>
</li>
<li><p>Object 생성자 함수 이외에도 String, Number, Boolean, Function, Array, Date, RegExp 등의 빌트인(built-in, 내장) 생성자 함수를 제공한다.</p>
</li>
<li><p>객체 리터럴을 사용하는 것이 더 간편하다.</p>
</li>
</ul>
<h2 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2. 생성자 함수"></a>2. 생성자 함수</h2><h3 id="2-1-객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#2-1-객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="2-1. 객체 리터럴에 의한 객체 생성 방식의 문제점"></a>2-1. 객체 리터럴에 의한 객체 생성 방식의 문제점</h3><ul>
<li>프로퍼티 구조가 동일하고 같은 프로퍼티와 메소드를 가진 객체를 여러개 생성해야 한다면, 매우 비효율적이다.</li>
</ul>
<h3 id="2-2-생성자-함수에-의한-객체-생성-방식의-장점"><a href="#2-2-생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="2-2. 생성자 함수에 의한 객체 생성 방식의 장점"></a>2-2. 생성자 함수에 의한 객체 생성 방식의 장점</h3><ul>
<li>템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 여러 개의 객체를 간편하게 생성할 수 있다.</li>
<li>일반 함수와 동일한 방법으로 정의하고, new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.</li>
<li>new 연산자와 함께 호출하지 않으면 일반 함수로 동작한다.</li>
</ul>
<h3 id="2-3-내부-메소드-Call-과-Construct"><a href="#2-3-내부-메소드-Call-과-Construct" class="headerlink" title="2-3. 내부 메소드 [[Call]] 과 [[Construct]]"></a>2-3. 내부 메소드 [[Call]] 과 [[Construct]]</h3><ul>
<li>함수는 객체이므로, 일반 객체의 내부 슬롯과 내부 메소드를 모두 가지고 있다.</li>
<li>[[Call]] &gt; callable &gt; 호출할 수 있는 객체, 함수.</li>
<li>[[Construct]] &gt; constructor &gt; 생성자 함수로서 호출할 수 있는 객체. new 연산자와 함께 호출. (또는 super 연산자)</li>
<li>일반적인 함수로서 호출되면 [[Call]] 호출, new연산자와 함께 호출되면 [[Construct]] 호출.</li>
<li>모든 함수는 모두 [[Call]]을 갖고있으나, [[Construct]]를 모두 갖지는 않는다. 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다.</li>
</ul>
<h3 id="2-4-constructor-non-constructor의-구분"><a href="#2-4-constructor-non-constructor의-구분" class="headerlink" title="2-4. constructor, non-constructor의 구분"></a>2-4. constructor, non-constructor의 구분</h3><ul>
<li>일반 함수로 정의된 함수만이 constructor. &gt; 생성자 함수로 호출.</li>
<li>함수가 어디에 할당되어 있는지에 따라 판단하는 것이 아니라 함수 정의 방식에 따라 함수의 종류를 구분한다.</li>
<li>함수의 종류가 Arrow, Method 인 함수는 non-structor.</li>
<li>일반 함수도 new 연산자를 붙여 호출하면 생성자 함수로 동작하므로, 파스칼 케이스로 구분한다.</li>
</ul>
<h3 id="2-5-생성자-함수의-인스턴스-생성-과정"><a href="#2-5-생성자-함수의-인스턴스-생성-과정" class="headerlink" title="2-5. 생성자 함수의 인스턴스 생성 과정"></a>2-5. 생성자 함수의 인스턴스 생성 과정</h3><ol>
<li>인스턴스 생성과 this 바인딩 : 암묵적으로 빈 객체가 생성되고(인스턴스), this에 바인딩(식별자와 값을 연결)된다. 함수 내부의 this가 함수가 생성할 인스턴스를 가리킨다.</li>
<li>인스턴스 초기화 : 생성자 함수 내의 코드가 실행되면 this에 바인딩되어 있는 인스턴스를 초기화한다. 인스턴스에 프로퍼티나 메소드를 추가하고, 인수로 전달받은 초기값을 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다.</li>
<li>인스턴스 반환 : </li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-prototype/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-prototype/" class="post-title-link" itemprop="url">javascript-prototype</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-07 20:39:39" itemprop="dateCreated datePublished" datetime="2020-03-07T20:39:39+09:00">2020-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-16 15:40:09" itemprop="dateModified" datetime="2020-03-16T15:40:09+09:00">2020-03-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="프로토타입"><a href="#프로토타입" class="headerlink" title="프로토타입"></a>프로토타입</h1><blockquote>
<p>자바스크립트는 객체 기반의 프로그래밍 언어.<br>자바스크립트를 이루고 있는 거의 ‘모든 것’ 이 객체이다.</p>
</blockquote>
<h2 id="1-객체지향-프로그래밍"><a href="#1-객체지향-프로그래밍" class="headerlink" title="1. 객체지향 프로그래밍"></a>1. 객체지향 프로그래밍</h2><h3 id="객체지향-프로그래밍-Object-Oriented-Programming-OOP"><a href="#객체지향-프로그래밍-Object-Oriented-Programming-OOP" class="headerlink" title="객체지향 프로그래밍 (Object Oriented Programming, OOP)"></a><strong>객체지향 프로그래밍 (Object Oriented Programming, OOP)</strong></h3><p>프로그램을 명령어 또는 함수의 목록이 아니라,<br>여러 개의 독립적 단위, 즉 객체들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임.</p>
<ul>
<li><p>추상화(abstraction) : 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려 내어 표현하는 것. 필요한 부분, 중요한 부분을 통합하여 하나로 만드는 것.</p>
</li>
<li><p>객체 : 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료 구조</p>
</li>
<li><blockquote>
<p>객체지향 프로그래밍 : 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임</p>
</blockquote>
</li>
<li><p>프로퍼티 : 객체의 상태 데이터</p>
</li>
<li><p>메소드 : 상태 데이터를 조작할 수 있는 동작</p>
</li>
<li><blockquote>
<p>객체 : 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조</p>
</blockquote>
</li>
</ul>
<h2 id="2-상속과-프로토타입"><a href="#2-상속과-프로토타입" class="headerlink" title="2. 상속과 프로토타입"></a>2. 상속과 프로토타입</h2><h3 id="상속-inheritance"><a href="#상속-inheritance" class="headerlink" title="상속 (inheritance)"></a><strong>상속 (inheritance)</strong></h3><ul>
<li>객체지향 프로그래밍의 핵심 개념</li>
<li>어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것</li>
<li>프로토타입에서 상속받아 중복을 제거하고 기존 코드를 재사용한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">  this.getArea &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; Math.PI 는 원주율을 나타내는 상수이다.</span><br><span class="line">    &#x2F;&#x2F; Math.pow 는 첫번째 인수를 두번째 인수로 거듭제곱한 값을 반환한다.</span><br><span class="line">    return Math.PI * Math.pow(this.radius, 2);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스 생성</span><br><span class="line">&#x2F;&#x2F; 반지름이 1인 인스턴스 생성</span><br><span class="line">const circle1 &#x3D; new Circle(1);</span><br><span class="line">&#x2F;&#x2F; 반지름이 2인 인스턴스 생성</span><br><span class="line">const circle2 &#x3D; new Circle(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는</span><br><span class="line">&#x2F;&#x2F; getArea 메소드를 중복 생성하고 모든 인스턴스가 중복 소유한다.</span><br><span class="line">&#x2F;&#x2F; 따라서 getArea 메소드는 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.</span><br><span class="line">console.log(circle1.getArea &#x3D;&#x3D;&#x3D; circle2.getArea);</span><br><span class="line"></span><br><span class="line">console.log(circle1.getArea());</span><br><span class="line">console.log(circle2.getArea());</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Circle(radius) &#123;</span><br><span class="line">  this.radius &#x3D; radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 </span><br><span class="line">&#x2F;&#x2F; getArea 메소드를 프로토타입에 추가한다.</span><br><span class="line">&#x2F;&#x2F; 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩 되어있다.</span><br><span class="line">Circle.prototype.getArea &#x3D; function () &#123;</span><br><span class="line">  return Math.PI * Math.pow(this.radius, 2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 인스턴스 생성</span><br><span class="line">const circle1 &#x3D; new Circle(1);</span><br><span class="line">const circle2 &#x3D; new Circle(2);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는</span><br><span class="line">&#x2F;&#x2F; 프로토타입 Circle.prototype 로부터 getArea 메소드를 상속받는다.</span><br><span class="line">&#x2F;&#x2F; 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.</span><br><span class="line">console.log(circle1.getArea &#x3D;&#x3D;&#x3D; circle2.getArea); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(circle1.getArea());</span><br><span class="line">console.log(circle2.getArea());</span><br></pre></td></tr></table></figure>
<h3 id="객체-리터럴-gt-생성자-함수-gt-프로토타입-기반으로-상속"><a href="#객체-리터럴-gt-생성자-함수-gt-프로토타입-기반으로-상속" class="headerlink" title="** 객체 리터럴 &gt; 생성자 함수 &gt; 프로토타입 기반으로 상속 **"></a>** 객체 리터럴 &gt; 생성자 함수 &gt; 프로토타입 기반으로 상속 **</h3><p>** 생성자 함수로 인스턴스를 생성하면 생성할 때마다 동일한 내용의 메소드를 중복 소유하게 된다 **<br>** 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 구현해놓으면 상속받아 사용할 수 있다. &gt; 상속 &gt; 코드의 재사용.** </p>
<h2 id="3-프로토타입-객체"><a href="#3-프로토타입-객체" class="headerlink" title="3. 프로토타입 객체"></a>3. 프로토타입 객체</h2><p>** 어떤 객체의 상위(부모) 객체 역할을 하는 객체. 다른 객체에 공유 프로퍼티(메소드)를 제공한다. 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다. **</p>
<ul>
<li>객체 리터럴에 의해 생성된 객체 &gt; 프로토타입 : Object.prototype</li>
<li>생성자 함수에 의해 생성된 객체 &gt; 프로토타입 : prototype 프로퍼티에 바인딩되어 있는 객체</li>
</ul>
<p>(모든 객체는 생성될 때 [[Prototype]] 내부 슬롯의 값으로 프로토타입의 참조를 저장한다. 모든 객체는 하나의 프로토타입을 갖고, 객체의 생성방식에 의해 결정된다.)</p>
<p>** ‘프로토타입 - 생성자 함수 - 객체’ 서로 연결되어 있다. **</p>
<ul>
<li>객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입에 접근할 수 있다.</li>
<li>프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있다.</li>
<li>생성자 함수는 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.</li>
</ul>
<h3 id="3-1-proto-접근자-프로퍼티"><a href="#3-1-proto-접근자-프로퍼티" class="headerlink" title="3-1. proto 접근자 프로퍼티"></a>3-1. <strong>proto</strong> 접근자 프로퍼티</h3><ul>
<li><p>모든 객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 접근할 수 있다.</p>
</li>
<li><p>[[Prototype]] 내부 슬롯에 직접 접근할 수 없으며, <strong>proto</strong> 접근자 프로퍼티를 통해 간접적으로 프로토타입에 접근할 수 있다.</p>
</li>
<li><p>접근자 프로퍼티는 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티.</p>
</li>
<li><p><strong>proto</strong> 접근자 프로퍼티를 통해 프로토타입에 접근하면 get <strong>proto</strong>가 호출된다.</p>
</li>
<li><p><strong>proto</strong> 접근자 프로퍼티를 통해 새로운 프로토타입을 할당하면 set <strong>proto</strong>가 호출된다.</p>
</li>
<li><p><strong>proto</strong> 접근자 프로퍼티는 상속을 통해 사용된다. &gt; <strong>proto</strong> 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티이다. 상속을 통해 Object.prototype.<strong>proto</strong> 접근자 프로퍼티를 사용할 수 있다.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const parent &#x3D; &#123;&#125;;</span><br><span class="line">const child &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; child의 프로토타입을 parent로 지정</span><br><span class="line">child.__proto__ &#x3D; parent;</span><br><span class="line">parent.__proto__ &#x3D; child; &#x2F;&#x2F; TypeError</span><br></pre></td></tr></table></figure>

<ul>
<li>프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다.</li>
<li><strong>proto</strong> 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천이다. &gt; 모든 객체가 <strong>proto</strong> 접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; obj는 프로토타입 체인의 종점이다. 따라서 Object.__proto__를 상속받을 수 없다.</span><br><span class="line">const obj &#x3D; Object.create(null);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj는 Object.__proto__를 상속받을 수 없다.</span><br><span class="line">console.log(obj.__proto__); &#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; 따라서 Object.getPrototypeOf 메소드를 사용하는 편이 좋다.</span><br><span class="line">console.log(Object.getPrototypeOf(obj)); &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.getPrototypeOf 메소드 : <code>__proto__</code> 접근자 프로퍼티 대신 프로토타입의 참조를 취득할 경우</li>
<li>Object.setPrototypeOf 메소드 : 프로토타입을 교체하는 경우</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;&#125;;</span><br><span class="line">const parent &#x3D; &#123; x: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 취득</span><br><span class="line">Object.getPrototypeOf(obj);</span><br><span class="line">console.log(Object.getPrototypeOf(obj));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj 객체의 프로토타입을 교체</span><br><span class="line">Object.setPrototypeOf(obj, parent);</span><br><span class="line">console.log(Object.setPrototypeOf(obj, parent));</span><br><span class="line">&#x2F;&#x2F; obj.__proto__ &#x3D; parent;</span><br><span class="line"></span><br><span class="line">console.log(obj.x); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<ul>
<li>프로토타입의 참조를 취득할 경우 : Object.getPrototypeOf 메소드</li>
<li>프로토타입을 교체하는 경우 : Object.setPrototypeOf 메소드</li>
<li>get Object.prototype.<strong>proto 와 set Object.prototype.</strong>proto__ 와 처리내용이 일치한다.</li>
</ul>
<h3 id="3-2-함수-객체의-prototype-프로퍼티"><a href="#3-2-함수-객체의-prototype-프로퍼티" class="headerlink" title="3-2. 함수 객체의 prototype 프로퍼티"></a>3-2. 함수 객체의 prototype 프로퍼티</h3><ul>
<li>함수 객체는 <strong>proto</strong> 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다.</li>
<li>함수 객체의 prototype 프로퍼티 &gt; 생성자 함수가 생성할 인스턴스의 프로토타입</li>
<li>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티. 일반 객체에는 없다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 객체는 prototype 프로퍼티를 소유한다.</span><br><span class="line">console.log((function () &#123;&#125;).hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span><br><span class="line">console.log(&#123;&#125;.hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<ul>
<li>prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</li>
<li>따라서 생성자 함수로 호출할 수 없는 함수, 함수의 종류가 Arrow, Method 인 함수. non-constructor 는 프로토타입이 생성되지 않으며, prototype 프로퍼티도 소유하지 않는다.</li>
<li>일반 함수도 prototype 프로퍼티를 소유하지만, 아무런 의미가 없다.</li>
<li>모든 객체가 가지고 있는 (Object.prototype로부터 상속받은) <strong>proto</strong> 접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">구분</th>
<th align="center">소유</th>
<th align="center">값</th>
<th align="center">사용 주체</th>
<th align="center">사용 목적</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>__proto__</code> 접근자 프로퍼티</td>
<td align="center">모든 객체</td>
<td align="center">프로토타입의 참조</td>
<td align="center">모든 객체</td>
<td align="center">모든 객체가 상속을 위해 자신의 프로토타입에 접근하기 위해 사용</td>
</tr>
<tr>
<td align="center">prototype 프로퍼티</td>
<td align="center">함수 객체</td>
<td align="center">프로토타입의 참조</td>
<td align="center">생성자 함수</td>
<td align="center">생성자 함수가 자신이 생성할 객체(인스턴스) 의 프로토타입을 할당하기 위해 사용</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Person(&#39;Lee&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Person 생성자 함수의 .prototype 과</span><br><span class="line">&#x2F;&#x2F; 생성한 인스턴스 me의 .__proto__ 는 동일한 프로토타입을 가리킨다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; me가 생성될 때 생성자 함수 Person 의</span><br><span class="line">&#x2F;&#x2F; prototype 프로퍼티를 통해 프로토타입을 할당.</span><br><span class="line">console.log(Person.prototype &#x3D;&#x3D;&#x3D; me.__proto__); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="3-3-프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#3-3-프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="3-3. 프로토타입의 constructor 프로퍼티와 생성자 함수"></a>3-3. 프로토타입의 constructor 프로퍼티와 생성자 함수</h3><ul>
<li>모든 프로토타입은 constructor 프로퍼티를 갖는다.</li>
<li>constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.</li>
<li>이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Person(&#39;Lee&#39;);</span><br><span class="line">const you &#x3D; new Person(&#39;Song&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수의 prototype</span><br><span class="line">console.log(Person.prototype);</span><br><span class="line">&#x2F;&#x2F; 생성된 인스턴스의 __proto__</span><br><span class="line">console.log(me.__proto__);</span><br><span class="line"></span><br><span class="line">console.log(me);</span><br><span class="line">console.log(me.name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Person &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Person &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; Person &#123; name: &#39;Lee&#39; &#125;</span><br><span class="line">&#x2F;&#x2F; Lee</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Person.prototype: Person 생성자 함수는 prototype 프로퍼티를 통해</span><br><span class="line">&#x2F;&#x2F; 자신이 생성할 인스턴스(me)의 프로토타입을 할당</span><br><span class="line">&#x2F;&#x2F; me.__proto__: 객체 me의 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입에 접근</span><br><span class="line">&#x2F;&#x2F; 결국 Person.prototype 과 me.__proto__는 결국 동일한 프로토타입을 가리킨다.</span><br><span class="line">console.log(Person.prototype &#x3D;&#x3D;&#x3D; me.__proto__); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; me 객체의 생성자 함수는 Person 이다.</span><br><span class="line">console.log(me.constructor &#x3D;&#x3D;&#x3D; Person); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(you);</span><br><span class="line">console.log(you.name);</span><br><span class="line"></span><br><span class="line">console.log(you.constructor);</span><br><span class="line">&#x2F;&#x2F; Person &#123; name: &#39;Song&#39; &#125;</span><br><span class="line">&#x2F;&#x2F; Song</span><br><span class="line">&#x2F;&#x2F; [Function: Person]</span><br></pre></td></tr></table></figure>

<h2 id="4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#4-리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h2><ul>
<li>생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다. 이 때 생성자 함수는 인스턴스를 생성한 생성자 함수이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; obj 객체를 생성한 생성자 함수는 Object 이다.</span><br><span class="line">const obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; add 함수 객체를 생성한 생성자 함수는 Function이다.</span><br><span class="line">const add &#x3D; new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 생성자 함수</span><br><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; me 객체를 생성한 생성자 함수는 Person이다.</span><br><span class="line">const me &#x3D; new Person(&#39;Lee&#39;);</span><br><span class="line"></span><br><span class="line">console.log(obj);</span><br><span class="line">console.log(Object);</span><br><span class="line">console.log(add);</span><br><span class="line">console.log(add(1, 2));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 리터럴</span><br><span class="line">const obj2 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 리터럴</span><br><span class="line">const add2 &#x3D; function (a, b) &#123; return a + b; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 배열 리터럴</span><br><span class="line">const arr &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 정규표현식 리터럴</span><br><span class="line">const regexr &#x3D; &#x2F;is&#x2F;ig;</span><br><span class="line"></span><br><span class="line">console.log(obj2);</span><br><span class="line">console.log(add2(2, 3));</span><br><span class="line">console.log(arr);</span><br><span class="line">console.log(regexr);</span><br></pre></td></tr></table></figure>

<ul>
<li>리터럴 표기법에 의해 생성된 객체도 프로토타입이 존재하지만, 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정할 수는 없다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 객체 obj는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성하였다.</span><br><span class="line">const obj3 &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 하지만 객체 obj의 생성자 함수는 Object 생성자 함수이다.</span><br><span class="line">console.log(obj.constructor &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<ul>
<li><p>객체 리터럴에 의해 생성된 객체가 Object 생성자 함수와 constructor 프로퍼티로 연결되어있다.</p>
</li>
<li><p>Object 생성자 함수는 new 연산자와 함께 호출하지 않아도 new 연산자와 함께 호출한 것과 동일하게 동작한다.</p>
</li>
<li><p>인수가 전달되지 않았을 때 추상연산 ObjectCreate을 호출하여 빈 객체를 생성한다. 인수가 전달된 경우에는 인수를 객체로 변환한다.</p>
</li>
<li><p>리터럴 표기법에 의해 생성된 객체도 생성자 함수와 연결된다.</p>
</li>
<li><p>프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재한다.</p>
</li>
<li><p>리터럴 표기법에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니지만 본질적인 면에서 큰 차이는 없다.</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">리터럴 표기법</th>
<th align="center">생성자 함수</th>
<th align="center">프로토타입</th>
</tr>
</thead>
<tbody><tr>
<td align="center">객체 리터럴</td>
<td align="center">Object</td>
<td align="center">Object.prototype</td>
</tr>
<tr>
<td align="center">함수 리터럴</td>
<td align="center">Function</td>
<td align="center">Function.prototype</td>
</tr>
<tr>
<td align="center">배열 리터럴</td>
<td align="center">Array</td>
<td align="center">Array.prototype</td>
</tr>
<tr>
<td align="center">정규 표현식 리터럴</td>
<td align="center">RegExp</td>
<td align="center">RegExp.prototype</td>
</tr>
</tbody></table>
<h2 id="5-프로토타입의-생성-시점"><a href="#5-프로토타입의-생성-시점" class="headerlink" title="5. 프로토타입의 생성 시점"></a>5. 프로토타입의 생성 시점</h2><ul>
<li><p>모든 객체는 생성자 함수와 연결되어 있다.</p>
</li>
<li><p>프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.</p>
</li>
<li><p>사용자 정의 생성자 함수, 빌트인 생성자 함수</p>
</li>
</ul>
<h3 id="5-1-사용자-정의-생성자-함수와-프로토타입-생성-시점"><a href="#5-1-사용자-정의-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="5-1. 사용자 정의 생성자 함수와 프로토타입 생성 시점"></a>5-1. 사용자 정의 생성자 함수와 프로토타입 생성 시점</h3><ul>
<li>함수 선언문으로 정의된 생성자 함수는 함수 호이스팅에 의해 먼저 평가되어 함수 객체와 프로토타입이 생성되고, 생성자 함수의 prototype 프로퍼티에 바인딩된다.</li>
<li>생성된 프로토타입의 프로토타입은 Object.prototype 이다.</li>
</ul>
<h3 id="5-2-빌트인-생성자-함수와-프로토타입-생성-시점"><a href="#5-2-빌트인-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="5-2. 빌트인 생성자 함수와 프로토타입 생성 시점"></a>5-2. 빌트인 생성자 함수와 프로토타입 생성 시점</h3><ul>
<li>모든 빌트인 생성자 함수는 전역객체가 생성되는 시점에 생성된다. 전역객체는 가장 먼저 생성되고, 이 때 빌트인 생성자 함수와 프로토타입이 생성되는데, 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다.</li>
<li>이처럼 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재하고 있다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[prototype]] 내부 슬롯에 할당된다. 이로써 생성된 객체는 프로토타입을 상속받는다.</li>
</ul>
<h2 id="6-객체-생성-방식과-프로토타입의-결정"><a href="#6-객체-생성-방식과-프로토타입의-결정" class="headerlink" title="6. 객체 생성 방식과 프로토타입의 결정"></a>6. 객체 생성 방식과 프로토타입의 결정</h2><ul>
<li>모든 객체는 추상연산(ObjectCreate)에 의해 생성된다.</li>
<li>프로토타입은 추상연산에 전달되는 인수(proto)에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.</li>
</ul>
<h3 id="6-1-객체-리터럴에-의해-생성된-객체의-프로토타입"><a href="#6-1-객체-리터럴에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-1. 객체 리터럴에 의해 생성된 객체의 프로토타입"></a>6-1. 객체 리터럴에 의해 생성된 객체의 프로토타입</h3><ul>
<li>자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때, 추상 연산 (ObjectCreate)를 호출 &gt; 추상연산에 전달되는 프로토타입은 Object.prototype &gt; 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype</li>
<li>객체는 Object.prototype을 프로토타입으로 갖게 된다 &gt; Object.prototype을 상속받는다 &gt; 객체 자체는 constructor 프로퍼티와 hasOwnProperty 메소드 등을 소유하지 않지만, 자신의 프로토타입인 Object.prototype의 constructor 프로퍼티와 hasOwnProperty 메소드를 자신의 자산인 것처럼 자유롭게 사용할 수 있다. = ** 객체가 Object.prototype 객체를 상속받았기 때문에. **</li>
</ul>
<h3 id="6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-2-Object-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-2. Object 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-2. Object 생성자 함수에 의해 생성된 객체의 프로토타입</h3><ul>
<li>Object 생성자 함수를 호출하면 추상연산 ObjectCreate를 호출한다 &gt; 추상연산에 전달되는 프로토타입은 Object.prototype = Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype 이다. &gt; 추상연산에 의해 Object 생성자 함수와 Object.prototype 과 생성된 객체 사이에 연결이 만들어진다. = ** 객체 리터럴에 의해 생성된 객체와 동일한 구조를 갖는다. **</li>
<li>객체 리터럴 방식은 내부에 프로퍼티를 추가하지만, Object 생성자 함수 방식은 일단 빈 객체를 생성한 후 프로퍼티를 추가해야 한다.</li>
</ul>
<h3 id="6-3-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#6-3-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="6-3. 생성자 함수에 의해 생성된 객체의 프로토타입"></a>6-3. 생성자 함수에 의해 생성된 객체의 프로토타입</h3><ul>
<li>Object.prototype은 다양한 빌트인 메소드(hasOwnPropert 등)를 갖고있지만, 사용자 정의 생성자 함수와 생성된 프로토타입은 constructor 뿐이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로토타입 메소드</span><br><span class="line">Person.prototype.sayHello &#x3D; function () &#123;</span><br><span class="line">  console.log(&#96;Hi! My name is $&#123;this.name&#125;&#96;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Person(&#39;Lee&#39;);</span><br><span class="line">const you &#x3D; new Person(&#39;Kim&#39;);</span><br><span class="line"></span><br><span class="line">me.sayHello();</span><br><span class="line">you.sayHello();</span><br><span class="line"></span><br><span class="line">console.log(me);</span><br><span class="line">console.log(Person.prototype);</span><br><span class="line"></span><br><span class="line">Person.prototype.address &#x3D; &#39;Seoul&#39;;</span><br><span class="line"></span><br><span class="line">console.log(me.address);</span><br><span class="line">console.log(me);</span><br><span class="line"></span><br><span class="line">Person.prototype.sayBye &#x3D; function () &#123;</span><br><span class="line">  console.log(&#96;Bye. $&#123;this.name&#125;&#96;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">me.sayBye();</span><br></pre></td></tr></table></figure>
<ul>
<li>Person 생성자 함수를 통해 생성된 모든 객체는 프로토타입에 추가된 sayHello 메소드를 상속받아 자신의 메소드처럼 사용할 수 있다.</li>
</ul>
<h2 id="7-프로토타입-체인"><a href="#7-프로토타입-체인" class="headerlink" title="7. 프로토타입 체인"></a>7. 프로토타입 체인</h2><ul>
<li>객체는 Object.prototype 메소드인 hasOwnProperty를 호출할 수 있다. 이는 Object.prototype 도 상속받았다는 의미이다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; hasOwnProperty는 Object.prototype의 메소드이다.</span><br><span class="line">console.log(me.hasOwnProperty(&#39;name&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(Object.getPrototypeOf(me) &#x3D;&#x3D;&#x3D; Person.prototype); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(Object.getPrototypeOf(Person.prototype) &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<ul>
<li><p>프로토타입 체인 : 객체의 프로퍼티, 메소드에 접근할 때 해당 객체에 없다면 <strong>proto</strong> 접근자 프로퍼티가 가리키는 링크를 따라 부모 프로토타입의 프로퍼티를 순차적으로 검색한다.</p>
</li>
<li><p>프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다.</p>
</li>
<li><p>프로토타입 체인의 최상위 객체는 Object.prototype 이다.</p>
</li>
<li><p>모든 객체는 Object.prototype을 상속받는다.</p>
</li>
<li><p>Object.prototype 은 프로토타입 체인의 종점 (End of prototype chain)이라 한다.</p>
</li>
<li><p>Object.prototype 의 프로토타입 [[Prototype]] 내부 슬롯의 값은 null이다.</p>
</li>
<li><p>Object.prototype 에서도 프로퍼티를 검색할 수 없는 경우, undefined를 반환한다.</p>
</li>
<li><p>프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘.</p>
</li>
<li><p>프로퍼티가 아닌 식별자는 스코프 체인에서 검색한다. &gt; 식별자 검색을 위한 메커니즘.</p>
</li>
<li><p>스코프 체인에서 식별자를 검색 &gt; 객체의 프로토타입 체인에서 프로퍼티나 메소드를 검색 = 스코프 체인과 프로토타입 체인은 서로 협력하여 식별자와 프로퍼티를 찾아낸다.</p>
</li>
</ul>
<h2 id="8-캡슐화"><a href="#8-캡슐화" class="headerlink" title="8. 캡슐화"></a>8. 캡슐화</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 생성자 함수</span><br><span class="line">  function Person(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 프로토타입 메소드</span><br><span class="line">  Person.prototype.sayHello &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;Hi! My name is $&#123;this.name&#125;&#96;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 생성자 함수를 반환</span><br><span class="line">  return Person;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">const me &#x3D; new Person(&#39;Lee&#39;);</span><br><span class="line"></span><br><span class="line">me.sayHello();</span><br></pre></td></tr></table></figure>
<ul>
<li>즉시 실행 함수를 사용하여 생성자 함수의 프로토타입을 확장하는 코드를 하나의 함수 내에 깔끔하게 모을 수 있다.</li>
<li>캡슐화(encapsulation)는 정보의 일부를 외부에 감추어 은닉(정보은닉 information hiding)하는 것을 말한다.</li>
<li>적절치 못한 접근으로부터 정보를 보호하고 객체간의 상호 의존성, 즉 결합도를 낮추는 효과.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const Person2 &#x3D; (function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 자유 변수이며 private 하다</span><br><span class="line">  let _name &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 생성자 함수</span><br><span class="line">  function Person2(name) &#123; _name &#x3D; name; &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 프로토타입 메소드</span><br><span class="line">  Person2.prototype.sayHello &#x3D; function () &#123;</span><br><span class="line">    console.log(&#96;Hi! My name is $&#123;_name&#125;&#96;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 생성자 함수를 반환</span><br><span class="line">  return Person2;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">const me2 &#x3D; new Person2(&#39;Lee&#39;);</span><br><span class="line"></span><br><span class="line">me2._name &#x3D; &#39;Kim&#39;;</span><br><span class="line">me2.sayHello();</span><br></pre></td></tr></table></figure>

<h2 id="9-오버라이딩과-프로퍼티-쉐도잉"><a href="#9-오버라이딩과-프로퍼티-쉐도잉" class="headerlink" title="9. 오버라이딩과 프로퍼티 쉐도잉"></a>9. 오버라이딩과 프로퍼티 쉐도잉</h2><ul>
<li>오버라이딩 (Overriding) : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용하는 방식이다.</li>
</ul>
<h2 id="10-프로토타입의-교체"><a href="#10-프로토타입의-교체" class="headerlink" title="10. 프로토타입의 교체"></a>10. 프로토타입의 교체</h2><h3 id="10-1-생성자-함수에-의한-프로토타입의-교체"><a href="#10-1-생성자-함수에-의한-프로토타입의-교체" class="headerlink" title="10-1. 생성자 함수에 의한 프로토타입의 교체"></a>10-1. 생성자 함수에 의한 프로토타입의 교체</h3><ul>
<li><h2 id="11-instanceof-연산자"><a href="#11-instanceof-연산자" class="headerlink" title="11. instanceof 연산자"></a>11. instanceof 연산자</h2></li>
<li><p>이항 연산자</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">객체 instanceof 생성자 함수</span><br></pre></td></tr></table></figure>

<h2 id="13-정적-프로퍼티-메소드"><a href="#13-정적-프로퍼티-메소드" class="headerlink" title="13. 정적 프로퍼티/메소드"></a>13. 정적 프로퍼티/메소드</h2><h2 id="14-프로퍼티-존재-확인"><a href="#14-프로퍼티-존재-확인" class="headerlink" title="14. 프로퍼티 존재 확인"></a>14. 프로퍼티 존재 확인</h2><ul>
<li>in 연산자</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key in object</span><br></pre></td></tr></table></figure>

<ul>
<li>hasOwnProperty 자기 자신의 프로퍼티만 확인 후 트루 펄스값</li>
<li>in은 상속까지 확인</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/review-type-casting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/review-type-casting/" class="post-title-link" itemprop="url">review-type-casting</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-04 21:06:51" itemprop="dateCreated datePublished" datetime="2020-03-04T21:06:51+09:00">2020-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-03-10 10:51:15" itemprop="dateModified" datetime="2020-03-10T10:51:15+09:00">2020-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/review/" itemprop="url" rel="index">
                    <span itemprop="name">review</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/review/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="자바스크립트-복습-타입-변환과-단축-평가"><a href="#자바스크립트-복습-타입-변환과-단축-평가" class="headerlink" title="자바스크립트 복습 - 타입 변환과 단축 평가"></a>자바스크립트 복습 - 타입 변환과 단축 평가</h1><ol>
<li><p>암묵적 타입 변환과 명시적 타입 변환<br>중요한 키워드 : 개발자의 의도<br>자바스크립트 엔진이 값을 평가하다가<br>예상하지 않았던 타입이 들어왔을 때 오류를 내지 않고 타입을 바꿔버리는 등의 동작을 일으키는 것이 암묵적 타입변환.<br>개발자가 프로그래밍을 할 때 타입변환이 필요한 부분에서 그 원리를 이용해서 의도적으로 타입변환을 할때 쓰는 것도  명시적 타입 변환이라고 한다<br>그 외에는 표준 빌트인 생성자 함수를 new 연산자 없이 호출하거나<br>빌트인 메소드를 이용하는 방법이 있다.<br>암묵적 타입변환과 명시적 타입변환을 어떤 방법으로 나누는 것은 적합하지 않고 경우에 따라서 그 원리를 사용하면 됨</p>
</li>
<li><p>단축평가 : 논리곱, 논리합<br>논리곱 &amp;&amp; AND 논리합 || OR 이 있는데<br>AND는 둘 다 true 여야 true 로 평가가 되고 하나라도 false 면 false 로 평가된다.<br>OR는 하나만 true 여도 true로 평가되고 둘 다 false 여야 false로 평가된다.<br>그래서 ‘Dog’ &amp;&amp; ‘Cat’ 의 예제에서<br>‘’ 빈 문자열 false 외에 모든 문자열은 true, truthy 값으로 평가되므로<br>Dog &amp;&amp; Cat 이면 &amp;&amp;는 첫번째가 true여도 두번째까지 확인해야 하므로 두번째 Cat을 확인하고 Cat을 반환하고<br>Dog || Cat 에서 ||는 첫번째만 true 여도 평가가 가능하므로 Dog를 확인 후 바로 Dog를 반환한다.</p>
</li>
<li><p>객체 - 객체 리터럴<br>프로퍼티키와 프로퍼티 값으로 이루어진 자료구조.<br>객체는 원시타입과 달리 변경 가능한 값.</p>
</li>
</ol>
<p>객체리터럴은 객체를 생성하는 표기법<br>중괄호{} 내에 0개 이상의 프로퍼티를 정의.<br>변수에 할당이 이루어지는 시점에 객체리터럴을 해석하여 생성함.</p>
<ol start="4">
<li>값에 의한 전달, 참조에 의한 전달<br>값에 의한 전달은 원시타입을 원시값을 변수에 할당한 후 다른 변수로 그 변수를 참조한 뒤 원래 변수의 값을 재할당한 경우 메모리 공간에서 따로 관리를 하기때문에 그 값을 복사한 다른 변수가 영향을 받지 않는다는 것.</li>
</ol>
<p>참조에 의한 전달은 객체를 아까와 같은 방법으로 다른 변수가 참조했을 때 객체에 어떤 프로퍼티를 추가하거나 변경했을 때 객체의 변수는 참조값을 메모리에 저장하고 있으므로 복사한 변수도 같은 참조값을 저장하기 때문에 객체를 추가 변경했을때 복사한 변수가 변경된 값을 그대로 출력하는 등 영향을 받는다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songseungeun.github.io/2020/03/javascript-first-class-object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="mare nubium">
      <meta itemprop="description" content="Front-end web development를 공부합니다.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mare nubium">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/javascript-first-class-object/" class="post-title-link" itemprop="url">javascript-first-class-object</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-03-04 13:47:19 / Modified: 18:05:57" itemprop="dateCreated datePublished" datetime="2020-03-04T13:47:19+09:00">2020-03-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/" itemprop="url" rel="index">
                    <span itemprop="name">Learn web development</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Learn-web-development/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="함수와-일급-객체"><a href="#함수와-일급-객체" class="headerlink" title="함수와 일급 객체"></a>함수와 일급 객체</h1><h2 id="1-일급-객체"><a href="#1-일급-객체" class="headerlink" title="1. 일급 객체"></a>1. 일급 객체</h2><blockquote>
<h4 id="아래와-같은-조건을-만족하는-객체를-일급-객체-first-class-object-라-한다"><a href="#아래와-같은-조건을-만족하는-객체를-일급-객체-first-class-object-라-한다" class="headerlink" title="아래와 같은 조건을 만족하는 객체를 일급 객체(first-class object)라 한다."></a>아래와 같은 조건을 만족하는 객체를 <code>일급 객체(first-class object)</code>라 한다.</h4><ol>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개 변수에게 전달할 수 있다.</li>
<li>함수의 결과값으로 반환할 수 있다.</li>
</ol>
<ul>
<li>자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체이다.</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수와 일급 객체</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1. 함수는 무명의 리터럴로 생성할 수 있다.</span><br><span class="line">&#x2F;&#x2F; 2. 함수는 변수에 저장할 수 있다.</span><br><span class="line">&#x2F;&#x2F; 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.</span><br><span class="line"></span><br><span class="line">const increase &#x3D; function (num) &#123;</span><br><span class="line">  return ++num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const decrease &#x3D; function (num) &#123;</span><br><span class="line">  return --num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 함수는 객체에 저장할 수 있다.</span><br><span class="line">const predicates &#x3D; &#123; increase, decrease &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 함수의 매개 변수에게 전달할 수 있다.</span><br><span class="line">&#x2F;&#x2F; 4. 함수의 반환값으로 사용할 수 있다.</span><br><span class="line">function makeCounter(predicate) &#123;</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  return function () &#123;</span><br><span class="line">    num &#x3D; predicate(num);</span><br><span class="line">    return num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 함수는 매개 변수에게 함수를 전달할 수 있다.</span><br><span class="line">const increaser &#x3D; makeCounter(predicates.increase);</span><br><span class="line">console.log(increaser());</span><br><span class="line">console.log(increaser());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 함수는 매개 변수에게 함수를 전달할 수 있다.</span><br><span class="line">const decreaser &#x3D; makeCounter(predicates.decrease);</span><br><span class="line">console.log(decreaser());</span><br><span class="line">console.log(decreaser());</span><br></pre></td></tr></table></figure>
<ul>
<li>함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다.</li>
<li>함수는 값을 사용할 수 있는 곳(변수 할당문, 객체의 프로퍼티, 배열의 요소, 함수 호출의 인수, 함수 반환문)이라면 어디서든지 리터럴로 정의할 수 있으며 런타임에 함수 객체로 평가된다.</li>
<li>함수 객체는 몇 가지 고유한 프로퍼티를 갖는 것을 제외하면 일반 객체와 동일하다. &gt; 일반 객체와 같이 함수의 매개 변수에 전달할 수 있으며 함수의 결과값으로 반환할 수도 있다. 이는 함수형 프로그래밍을 가능케하는 자바스크립트의 장점 중에 하나이다.</li>
</ul>
<ul>
<li>함수형 프로그래밍 : 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화하여 불변성을 지향하는 프로그래밍 패러다임이다. 함수형 프로그래밍 패러다임에서 매개 변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를 고차 함수(Higher-Order Function, HOF)라 한다.</li>
</ul>
<ul>
<li>함수는 객체이지만 일반 객체와는 차이가 있다. 일반 객체는 호출할 수 없지만 함수 객체는 호출할 수 있다. 그리고 일반 객체에는 없는 함수 고유의 프로퍼티를 소유한다.</li>
</ul>
<h2 id="2-함수-객체의-프로퍼티"><a href="#2-함수-객체의-프로퍼티" class="headerlink" title="2. 함수 객체의 프로퍼티"></a>2. 함수 객체의 프로퍼티</h2><ul>
<li><p>함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다.</p>
</li>
<li><p>console.dir(브라우저 콘솔) 메소드를 사용하여 함수 객체의 내부를 들여다 보자.</p>
</li>
<li><p>일반 객체에는 없는 arguments, caller, length, name, prototype 프로퍼티가 함수 객체에는 존재한다. 이 프로퍼티들의 프로퍼티 어트리뷰트를 Object.getOwnPropertyDescriptor 메소드로 확인해보면 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 객체의 프로퍼티</span><br><span class="line">function square(number) &#123;</span><br><span class="line">  return number * number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.dir(square);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; arguments, caller, length, name, prototype 프로퍼티는</span><br><span class="line">&#x2F;&#x2F; 모두 square 함수 객체의 데이터 프로퍼티이다.</span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;arguments&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;arguments&#39;));</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;caller&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;caller&#39;));</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;length&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;length&#39;));</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;name&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;name&#39;));</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;prototype&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;prototype&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; __proto__는 square 함수 객체의 프로퍼티가 아니다.</span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;__proto__&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(square, &#39;__proto__&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; __proto__는 Object.prototype 객체의 접근자 프로퍼티이다.</span><br><span class="line">&#x2F;&#x2F; square 함수 객체는 Object.prototype 객체로부터 __proto__ 접근자 프로퍼티를 상속받는다.</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, &#39;__proto__&#39;);</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(Object.prototype, &#39;__proto__&#39;));</span><br></pre></td></tr></table></figure></li>
<li><p><code>__proto__</code> 는 접근자 프로퍼티이며 함수 객체의 프로퍼티가 아닌 Object.prototype 객체의 프로퍼티를 상속받은 것을 알 수 있다.</p>
</li>
</ul>
<h3 id="2-1-arguments-프로퍼티"><a href="#2-1-arguments-프로퍼티" class="headerlink" title="2-1. arguments 프로퍼티"></a>2-1. arguments 프로퍼티</h3><ul>
<li>함수 객체의 arguments 프로퍼티 값은 arguments 객체이다.</li>
<li>arguments 객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회 가능한(iterable) 유사 배열 객체(array-like object)이며 함수 내부에서 지역 변수처럼 사용된다.</li>
<li>함수 외부에서는 사용할 수 없다.</li>
</ul>
<ul>
<li>arguments 프로퍼티 : ES3부터 표준에서 폐지되었다. Function.arguments와 같은 사용방법은 권장되지 않으며 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체를 참조하도록 한다.</li>
</ul>
<ul>
<li>함수 호출 시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; arguments 프로퍼티</span><br><span class="line">function multiply(x, y) &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(multiply());</span><br><span class="line">console.log(multiply(1));</span><br><span class="line">console.log(multiply(1, 2));</span><br><span class="line">console.log(multiply(1, 2, 3));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [Arguments] &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; NaN</span><br><span class="line">&#x2F;&#x2F; [Arguments] &#123; &#39;0&#39;: 1 &#125;</span><br><span class="line">&#x2F;&#x2F; NaN</span><br><span class="line">&#x2F;&#x2F; [Arguments] &#123; &#39;0&#39;: 1, &#39;1&#39;: 2 &#125;</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; [Arguments] &#123; &#39;0&#39;: 1, &#39;1&#39;: 2, &#39;2&#39;: 3 &#125;</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<ul>
<li>함수를 정의할 때 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다.</li>
<li>즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다.</li>
<li>선언된 매개변수의 개수보다 인수가 적게 전달했을 경우 undefined 로 초기화된 상태를 유지한다.</li>
<li>매개변수의 개수보다 인수를 더 많이 전달한 경우 초과된 인수는 무시된다.</li>
<li>초과된 인수가 버려지는 것은 아니고, 암묵적으로 arguments 객체의 프로퍼티로 보관된다.</li>
<li>arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타낸다.</li>
<li>arguments 객체의 callee 프로퍼티는 호출되어 arguments 객체를 생성한 함수, 즉 함수 자신을 가리키고 arguments 객체의 length 프로퍼티는 인수의 개수를 가리킨다.</li>
</ul>
<ul>
<li>arguments 객체의 symbol(symbol.iterator) 프로퍼티 : arguments 객체를 순회 가능한 자료구조인 이터러블(iterable)로 만들기 위한 프로퍼티다. symbol.iterator를 프로퍼티 키로 사용한 메소드를 구현하는 것에 의해 이터러블이 된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; iterator</span><br><span class="line"></span><br><span class="line">function multiply(x, y) &#123;</span><br><span class="line">  &#x2F;&#x2F; 이터레이터</span><br><span class="line">  const iterator &#x3D; arguments[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 이터레이터의 next 메소드를 호출하여 이터러블 객체 arguments를 순회</span><br><span class="line">  console.log(iterator.next());</span><br><span class="line">  console.log(iterator.next());</span><br><span class="line">  console.log(iterator.next());</span><br><span class="line">  console.log(iterator.next());</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; &#123; value: 1, done: false &#125;</span><br><span class="line">  &#x2F;&#x2F; &#123; value: 2, done: false &#125;</span><br><span class="line">  &#x2F;&#x2F; &#123; value: 3, done: false &#125;</span><br><span class="line">  &#x2F;&#x2F; &#123; value: undefined, done: true &#125;</span><br><span class="line"></span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">multiply(1, 2, 3);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>선언된 매개변수의 개수와 함수 호출시에 전달하는 인수의 개수를 확인하지 않은 자바스크립트의 특성때문에 런타임 시에 호출된 함수의 인자 개수를 확인하고, 이에 따라 함수의 동작을 달리 정의할 필요가 있을 수 있다. 이 때 유용하게 사용되는 것이 arguments 객체이다.</p>
</li>
<li><p>arguments 객체는 매개변수 개수를 확정할 수 없는 <code>가변 인자 함수</code>를 구현할 때 유용하게 사용된다.</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  let res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로</span><br><span class="line">  &#x2F;&#x2F; for 문으로 순회할 수 있다.</span><br><span class="line">  for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    res +&#x3D; arguments[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum());</span><br><span class="line">console.log(sum(1, 2));</span><br><span class="line">console.log(sum(1, 2, 3));\</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<ul>
<li>arguments 객체는 배열의 형태로 인자 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다.</li>
<li>유사배열객체란 length 프로퍼티를 가진 객체로 for문으로 순회할 수 있는 객체를 말한다.</li>
</ul>
<ul>
<li>유사배열객체와 이터러블 : ES6에서 도입된 이터레이션 프로토콜을 준수하면 순회 가능한 자료 구조인 이터러블이 된다. 이터러블의 개념이 없었던 ES5 에서 arguments 객체는 유사 배열 객체로 구분되었다. 하지만 이터러블이 도입된 ES6 부터 arguments 객체는 유사 배열 객체이면서 이터러블이다.</li>
</ul>
<ul>
<li>유사 배열 객체는 배열이 아니므로 배열 메소드를 사용할 경우 에러가 발생하게 된다.</li>
<li>배열 메소드를 사용하려면 Function.prototype.call, Function.prototype.apply 를 사용해 간접 호출해야 하는 번거로움이 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; function.prototype.call, function.prototype.apply</span><br><span class="line"></span><br><span class="line">function sum() &#123;</span><br><span class="line">  &#x2F;&#x2F; arguments 객체를 배열로 변환</span><br><span class="line">  const array &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">  return array.reduce(function (pre, cur) &#123;</span><br><span class="line">    return pre + cur;</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1, 2, 3, 4, 5)); &#x2F;&#x2F; 15</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES6 에서는 Rest 파라미터를 도입.</span><br><span class="line">&#x2F;&#x2F; ES6 Rest parameter</span><br><span class="line">function sum2( ...args ) &#123;</span><br><span class="line">  return args.reduce((pre, cur) &#x3D;&gt; pre + cur, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1, 2, 3, 4, 5)); &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>
<ul>
<li>이러한 번거로움을 해결하기 위해 ES6 에서는 Rest 파라미터를 도입했다.</li>
</ul>
<h3 id="2-3-length-프로퍼티"><a href="#2-3-length-프로퍼티" class="headerlink" title="2-3. length 프로퍼티"></a>2-3. length 프로퍼티</h3><ul>
<li>함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킨다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; length property</span><br><span class="line"></span><br><span class="line">function foo() &#123;&#125;</span><br><span class="line">console.log(foo.length); &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">function bar(x) &#123;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">console.log(bar.length); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">function baz(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line">console.log(baz.length); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<ul>
<li>arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있으므로 주의하여야 한다.</li>
<li>arguments 객체의 length 프로퍼티는 인자의 개수</li>
<li>함수 객체의 length 프로퍼티는 매개변수의 개수.</li>
</ul>
<h3 id="2-4-name-프로퍼티"><a href="#2-4-name-프로퍼티" class="headerlink" title="2-4. name 프로퍼티"></a>2-4. name 프로퍼티</h3><ul>
<li>함수 객체의 name 프로퍼티는 함수 이름을 나타낸다. </li>
<li>ES5 와 ES6 에서 동작을 달리하므로 주의.</li>
<li>익명 함수 표현식의 경우 ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다.</li>
<li>ES6에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; name property</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 기명 함수 표현식</span><br><span class="line">var namedFunc &#x3D; function foo() &#123;&#125;;</span><br><span class="line">console.log(namedFunc.name); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 익명 함수 표현식</span><br><span class="line">var anonymousFunc &#x3D; function() &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; ES5: name 프로퍼티는 빈 문자열을 값으로 갖는다.</span><br><span class="line">&#x2F;&#x2F; ES6: name 프로퍼티는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.</span><br><span class="line">console.log(anonymousFunc.name); &#x2F;&#x2F; anonymousFunc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 선언문(Function declaration)</span><br><span class="line">function bar() &#123;&#125;</span><br><span class="line">console.log(bar.name); &#x2F;&#x2F; bar</span><br></pre></td></tr></table></figure>
<ul>
<li>함수 이름과 함수 객체를 가리키는 변수 이름은 의미가 다르다.</li>
<li>함수를 호출할 때는 함수 이름이 아닌 함수 객체를 가리키는 변수 이름으로 호출한다.</li>
</ul>
<h3 id="2-5-proto-접근자-프로퍼티"><a href="#2-5-proto-접근자-프로퍼티" class="headerlink" title="2-5. __proto__ 접근자 프로퍼티"></a>2-5. <code>__proto__</code> 접근자 프로퍼티</h3><ul>
<li>모든 객체는 <code>[[Prototype]]</code> 이라는 내부 슬롯을 갖는다.</li>
<li><code>[[Prototype]]</code> 내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.</li>
<li><code>__proto__</code> 프로퍼티는 <code>[[Prototype]]</code>내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다.</li>
<li>내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.</li>
<li><code>[[Prototype]]</code>내부 슬롯에도 간접적으로 프로토타입 객체에 접근할 수 있다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; __proto__ 접근자 프로퍼티</span><br><span class="line"></span><br><span class="line">const obj &#x3D; &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype 이다.</span><br><span class="line">console.log(obj.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인</span><br><span class="line">&#x2F;&#x2F; Object.prototype의 프로퍼티를 상속받는다.</span><br><span class="line">&#x2F;&#x2F; hasOwnProperty 메소드는 Object.prototype 의 메소드이다.</span><br><span class="line">console.log(obj.hasOwnProperty(&#39;a&#39;)); &#x2F;&#x2F; true</span><br><span class="line">console.log(obj.hasOwnProperty(&#39;__proto__&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<p>(왜 true, false 가 나오는지 다시 체크할 것)</p>
<h3 id="2-6-prototype-프로퍼티"><a href="#2-6-prototype-프로퍼티" class="headerlink" title="2-6. prototype 프로퍼티"></a>2-6. prototype 프로퍼티</h3><ul>
<li>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다.</li>
<li>일반 객체에는 prototype 프로퍼티가 없다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; prototype property</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 객체는 prototype 프로퍼티를 소유한다.</span><br><span class="line">console.log((function() &#123;&#125;).hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span><br><span class="line">console.log((&#123;&#125;).hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure></li>
<li>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mare nubium</p>
  <div class="site-description" itemprop="description">Front-end web development를 공부합니다.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mare nubium</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
